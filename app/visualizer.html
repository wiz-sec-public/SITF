
<!DOCTYPE html>
<html lang="en" class="theme-dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SITF Attack Flow Visualizer</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%23FC80FF'/><stop offset='100%25' style='stop-color:%239D4EDD'/></linearGradient></defs><circle cx='50' cy='50' r='45' fill='%230A0E27'/><path d='M 30 50 L 45 50 L 50 35 L 55 65 L 60 45 L 70 45' stroke='url(%23g)' stroke-width='4' fill='none' stroke-linecap='round' stroke-linejoin='round'/><circle cx='30' cy='50' r='4' fill='%2310B981'/><circle cx='70' cy='45' r='4' fill='%23EF4444'/><path d='M 50 20 L 50 30 M 42 24 L 50 20 L 58 24' stroke='%23FC80FF' stroke-width='2' fill='none' stroke-linecap='round'/></svg>">
    
    <!-- Poppins Font (Wiz Style) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and React DOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- React Flow -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reactflow@11/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/reactflow@11/dist/umd/index.min.js"></script>
    
    <!-- html2canvas for PNG export -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        :root {
            /* Dark mode colors (default) */
            --wiz-dark-bg: #0f0f0f;
            --wiz-dark-surface: #1a1a1a;
            --wiz-dark-border: #333333;
            --wiz-dark-hover: #252525;
            --wiz-text-primary: #e5e5e5;
            --wiz-text-secondary: #a0a0a0;
            --wiz-accent-purple: #FC80FF;
            --wiz-accent-blue: #4A90E2;
            --wiz-success: #10B981;
            --wiz-danger: #EF4444;
            --wiz-warning: #F59E0B;
            --wiz-edge-color: #666666;
            --wiz-scrollbar-track: #0f0f0f;
            --wiz-scrollbar-thumb: #333333;
            --wiz-scrollbar-thumb-hover: #444444;
        }
        
        /* Light mode colors */
        .theme-light {
            --wiz-dark-bg: #ffffff;
            --wiz-dark-surface: #f9fafb;
            --wiz-dark-border: #e5e7eb;
            --wiz-dark-hover: #f3f4f6;
            --wiz-text-primary: #1f2937;
            --wiz-text-secondary: #6b7280;
            --wiz-accent-purple: #a855f7;
            --wiz-accent-blue: #3b82f6;
            --wiz-success: #10B981;
            --wiz-danger: #EF4444;
            --wiz-warning: #F59E0B;
            --wiz-edge-color: #9ca3af;
            --wiz-scrollbar-track: #f9fafb;
            --wiz-scrollbar-thumb: #d1d5db;
            --wiz-scrollbar-thumb-hover: #9ca3af;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background: var(--wiz-dark-bg);
            color: var(--wiz-text-primary);
        }
        
        .palette-container {
            min-width: 200px;
            max-width: 600px;
            background: var(--wiz-dark-surface);
            border-right: 1px solid var(--wiz-dark-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            background: transparent;
            z-index: 1000;
            transition: all 0.2s;
        }
        
        .resize-handle:hover,
        .resize-handle.resizing {
            background: var(--wiz-accent-purple);
            box-shadow: 0 0 10px rgba(252, 128, 255, 0.5);
        }
        
        /* React Flow Dark Theme Overrides */
        .react-flow {
            background: var(--wiz-dark-bg);
        }
        
        .react-flow__node {
            font-size: 12px;
        }
        
        .react-flow__edge-path {
            stroke-width: 2;
            stroke: var(--wiz-edge-color);
        }
        
        .react-flow__edge-text {
            font-size: 11px;
        }
        
        .react-flow__controls {
            background: var(--wiz-dark-surface);
            border: 1px solid var(--wiz-dark-border);
            border-radius: 8px;
        }
        
        .react-flow__controls button {
            background: var(--wiz-dark-surface);
            border-bottom: 1px solid var(--wiz-dark-border);
            color: var(--wiz-text-primary);
        }
        
        .react-flow__controls button:hover {
            background: var(--wiz-dark-hover);
        }
        
        .react-flow__minimap {
            background: var(--wiz-dark-surface);
            border: 1px solid var(--wiz-dark-border);
            border-radius: 8px;
        }
        
        .react-flow__background {
            background: var(--wiz-dark-bg);
        }
        
        .palette-item {
            cursor: grab;
            transition: all 0.2s ease;
            background: var(--wiz-dark-surface);
            border: 1px solid var(--wiz-dark-border);
        }
        
        .palette-item:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(252, 128, 255, 0.2);
            border-color: var(--wiz-accent-purple);
        }
        
        .palette-item:active {
            cursor: grabbing;
            transform: translateX(2px);
        }
        
        /* Multi-selection box styling */
        .react-flow__selectionpane {
            background: rgba(252, 128, 255, 0.1);
            border: 2px dashed var(--wiz-accent-purple);
        }
        
        .react-flow__node.selected {
            box-shadow: 0 0 0 2px var(--wiz-accent-purple);
        }
        
        .component-node {
            min-width: 200px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            background-color: var(--wiz-dark-surface);
            border: 1px solid var(--wiz-dark-border);
        }
        
        /* Force component nodes to always be in background */
        .react-flow__node[data-type="component"] {
            z-index: -1 !important;
        }
        
        /* Keep components in background even when selected */
        .react-flow__node[data-type="component"].selected {
            z-index: -1 !important;
        }
        
        /* Technique nodes and other nodes on top */
        .react-flow__node[data-type="technique"],
        .react-flow__node[data-type="entryPoint"],
        .react-flow__node[data-type="exitPoint"] {
            z-index: 10 !important;
        }
        
        /* Keep technique nodes on top even when not selected */
        .react-flow__node[data-type="technique"]:not(.selected),
        .react-flow__node[data-type="entryPoint"]:not(.selected),
        .react-flow__node[data-type="exitPoint"]:not(.selected) {
            z-index: 10 !important;
        }
        
        /* Edges should be above component nodes but below technique nodes and popups */
        .react-flow__edge {
            z-index: 5 !important;
        }
        
        /* Ensure edge labels are also at same level as edges */
        .react-flow__edge-text {
            z-index: 5 !important;
        }
        
        /* Force popups to be above everything including edges */
        .technique-popup {
            z-index: 1000 !important;
            position: absolute !important;
        }
        
        .technique-node {
            font-size: 11px;
            padding: 8px;
            margin: 4px;
            background: var(--wiz-dark-surface);
            border-radius: 6px;
            border: 1px solid var(--wiz-dark-border);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .entry-exit-node {
            border-radius: 20px;
            padding: 12px 20px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-track {
            background: var(--wiz-scrollbar-track);
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: var(--wiz-scrollbar-thumb);
            border-radius: 4px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: var(--wiz-scrollbar-thumb-hover);
        }
        
        .matrix-resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            cursor: row-resize;
            background: transparent;
            z-index: 1000;
            transition: all 0.2s;
        }
        
        .matrix-resize-handle:hover,
        .matrix-resize-handle.resizing {
            background: var(--wiz-accent-purple);
            box-shadow: 0 0 10px rgba(252, 128, 255, 0.5);
        }
        
        /* Wiz-style buttons */
        .wiz-button {
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
        }
        
        .wiz-button-primary {
            background: var(--wiz-accent-purple);
            color: var(--wiz-dark-bg);
        }
        
        .wiz-button-primary:hover {
            background: #FF99FF;
            box-shadow: 0 4px 12px rgba(252, 128, 255, 0.3);
        }
        
        .wiz-button-secondary {
            background: var(--wiz-dark-surface);
            color: var(--wiz-text-primary);
            border: 1px solid var(--wiz-dark-border);
        }
        
        .wiz-button-secondary:hover {
            background: var(--wiz-dark-hover);
            border-color: var(--wiz-accent-purple);
        }
        
        .wiz-button-success {
            background: var(--wiz-success);
            color: white;
        }
        
        .wiz-button-success:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .wiz-button-danger {
            background: var(--wiz-danger);
            color: white;
        }
        
        .wiz-button-danger:hover {
            background: #DC2626;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useCallback, useRef, useEffect } = React;
        const {
            ReactFlow,
            Background,
            Controls,
            MiniMap,
            useNodesState,
            useEdgesState,
            addEdge,
            MarkerType,
            Handle,
            Position,
            NodeResizer
        } = window.ReactFlow;
        
        // Embedded techniques data - generated by build.py from TECHNIQUE_LIBRARY.md
        const techniquesData = {
  "components": [
    {
      "id": "endpoint",
      "name": "Endpoint/IDE",
      "description": "Developer workstations and development environments"
    },
    {
      "id": "vcs",
      "name": "VCS",
      "description": "Version Control Systems (GitHub, GitLab, Azure DevOps)"
    },
    {
      "id": "cicd",
      "name": "CI/CD",
      "description": "Continuous Integration/Deployment systems"
    },
    {
      "id": "registry",
      "name": "Registry",
      "description": "Container and artifact registries (NPM, Docker, PyPI)"
    },
    {
      "id": "production",
      "name": "Production/Cloud",
      "description": "Production infrastructure of the producer organization"
    }
  ],
  "entryPoints": [
    "Phishing",
    "Compromised Dependency",
    "Vulnerability Exploit",
    "Stolen Credentials",
    "Social Engineering",
    "Custom"
  ],
  "exitPoints": [
    "Future Breach",
    "Persistence Established",
    "Secondary Supply Chain Attack",
    "Detection & Containment",
    "Custom"
  ],
  "techniques": [
    {
      "id": "T-E001",
      "name": "Malicious Execution on Endpoint",
      "component": "endpoint",
      "stage": "Initial Access",
      "description": "Attacker executes malicious code on developer workstation",
      "risks": [
        "Using untrusted IDE extensions",
        "Using untrusted software packages on endpoints",
        "No EDR",
        "Lack of application sandboxing",
        "Package installation scripts enabled",
        "Direct downloads from public registries"
      ],
      "controls": {
        "protective": [
          {
            "name": "Local registry proxy with filtering"
          },
          {
            "name": "IDE sandboxing"
          },
          {
            "name": "Mandating signed extensions"
          },
          {
            "name": "Package version pinning"
          },
          {
            "name": "Automated maintainer reputation and hygiene checks"
          },
          {
            "name": "Application whitelisting"
          },
          {
            "name": "Disable package installation scripts (--ignore-scripts)"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          }
        ]
      }
    },
    {
      "id": "T-E002",
      "name": "Endpoint Phishing",
      "component": "endpoint",
      "stage": "Initial Access",
      "description": "Attacker phishes developer to steal credentials or install malware",
      "risks": [
        "Lack of 2FA / phishing protection",
        "No security awareness training",
        "Credentials stored in plaintext",
        "No email security controls"
      ],
      "controls": {
        "protective": [
          {
            "name": "Mandatory MFA"
          },
          {
            "name": "Phishing-resistant authentication"
          },
          {
            "name": "Security awareness training"
          },
          {
            "name": "Email security (SPF, DMARC, DKIM)"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          }
        ]
      }
    },
    {
      "id": "T-E003",
      "name": "Harvest Local Secrets / Credentials from Endpoint",
      "component": "endpoint",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker extracts credentials stored on developer machine",
      "risks": [
        "Credentials stored in plaintext",
        "Production credentials on developer machines",
        "No local DLP",
        "SSH keys without passwords",
        "Cloud credentials in environment variables"
      ],
      "controls": {
        "protective": [
          {
            "name": "Credential manager enforcement"
          },
          {
            "name": "No production credentials on endpoints"
          },
          {
            "name": "Encrypted credential storage"
          }
        ],
        "detective": [
          {
            "name": "Local DLP"
          },
          {
            "name": "EDR on endpoint"
          }
        ]
      }
    },
    {
      "id": "T-E004",
      "name": "Harvest Local Data from Endpoint",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker exfiltrates source code, documents, or other sensitive data from endpoint",
      "risks": [
        "No local DLP",
        "No EDR",
        "Sensitive data stored locally",
        "No encryption at rest"
      ],
      "controls": {
        "protective": [
          {
            "name": "Data classification and handling policies"
          },
          {
            "name": "Encryption at rest"
          }
        ],
        "detective": [
          {
            "name": "Local DLP"
          },
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Network monitoring"
          }
        ]
      }
    },
    {
      "id": "T-E005",
      "name": "Cryptomining on Endpoints",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker uses endpoint resources for cryptocurrency mining",
      "risks": [
        "No EDR",
        "Untrusted software packages",
        "No resource monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Application whitelisting"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Resource monitoring and alerting"
          },
          {
            "name": "Network monitoring (detect mining pool connections)"
          }
        ]
      }
    },
    {
      "id": "T-E006",
      "name": "Register Local Machine as CI Runner",
      "component": "endpoint",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker registers compromised endpoint as self-hosted CI/CD runner",
      "risks": [
        "Ability to register arbitrary machines as runners",
        "No runner registration approval process",
        "Runner registration tokens not protected"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed runners only"
          },
          {
            "name": "Runner registration approval workflow"
          },
          {
            "name": "Runner registration token protection"
          },
          {
            "name": "Network segmentation (runners isolated from endpoints)"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-E007",
      "name": "Abuse Local VCS Access from Endpoint",
      "component": "endpoint",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses local git credentials to access VCS",
      "risks": [
        "VCS credentials stored on endpoint",
        "No credential rotation",
        "Overprivileged VCS access"
      ],
      "controls": {
        "protective": [
          {
            "name": "Credential manager enforcement"
          },
          {
            "name": "Fine-grained PATs with expiration"
          },
          {
            "name": "Mandatory MFA for VCS"
          }
        ],
        "detective": [
          {
            "name": "Audit log monitoring"
          }
        ]
      }
    },
    {
      "id": "T-E008",
      "name": "Abuse Local CI/CD Access from Endpoint",
      "component": "endpoint",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses local CI/CD credentials to access CI/CD system",
      "risks": [
        "CI/CD credentials stored on endpoint",
        "No credential rotation",
        "Overprivileged CI/CD access"
      ],
      "controls": {
        "protective": [
          {
            "name": "Credential manager enforcement"
          },
          {
            "name": "OIDC instead of long-lived tokens"
          },
          {
            "name": "Mandatory MFA for CI/CD"
          }
        ],
        "detective": [
          {
            "name": "Audit log monitoring"
          }
        ]
      }
    },
    {
      "id": "T-E009",
      "name": "Abuse Local AI Tools",
      "component": "endpoint",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses AI coding assistants to exfiltrate code or inject malicious suggestions",
      "risks": [
        "Using untrusted AI tools",
        "No acceptable use policy",
        "AI tools with excessive permissions",
        "Sensitive code sent to AI services"
      ],
      "controls": {
        "protective": [
          {
            "name": "Acceptable use policy against unapproved AI tools"
          },
          {
            "name": "Approved AI tools with data protection"
          },
          {
            "name": "Code review for AI-generated code"
          }
        ],
        "detective": [
          {
            "name": "Network monitoring for AI service connections"
          }
        ]
      }
    },
    {
      "id": "T-E010",
      "name": "Endpoint Infrastructure Destruction",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker destroys or corrupts endpoint systems, data, or configurations to cause operational disruption",
      "risks": [
        "No backup and recovery",
        "Overprivileged local user accounts",
        "No EDR",
        "Lack of system integrity monitoring",
        "Insufficient access controls on critical system files"
      ],
      "controls": {
        "protective": [
          {
            "name": "Regular endpoint backups"
          },
          {
            "name": "Minimal local user privileges"
          },
          {
            "name": "Offline backup storage"
          },
          {
            "name": "File system access controls"
          },
          {
            "name": "Endpoint recovery procedures"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "System integrity monitoring"
          }
        ]
      }
    },
    {
      "id": "T-E011",
      "name": "Unicode Stealth Code Injection",
      "component": "endpoint",
      "stage": "Initial Access",
      "description": "Attacker uses invisible Unicode characters (variation selectors, zero-width characters) to hide malicious code that doesn't render in code editors but executes normally",
      "risks": [
        "Using untrusted IDE extensions",
        "No code review detection of invisible characters",
        "Static analysis tools miss unprintable characters",
        "Diff tools don't highlight invisible code",
        "Developer trust in visual code inspection"
      ],
      "controls": {
        "protective": [
          {
            "name": "IDE plugins to visualize invisible characters"
          },
          {
            "name": "Static analysis with Unicode normalization"
          },
          {
            "name": "Extension code signing and verification"
          },
          {
            "name": "Mandatory code review with specialized tools"
          }
        ],
        "detective": [
          {
            "name": "Unicode character detection in code review tools"
          },
          {
            "name": "Automated detection of unprintable characters in commits"
          }
        ]
      }
    },
    {
      "id": "T-E012",
      "name": "SOCKS Proxy Deployment on Endpoint",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker deploys SOCKS proxy server on compromised endpoint to route malicious traffic through victim's network and IP address",
      "risks": [
        "No EDR",
        "No network egress monitoring",
        "Unrestricted outbound connections",
        "Endpoint inside corporate network",
        "No process monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Application whitelisting"
          },
          {
            "name": "Network segmentation (endpoints from production)"
          },
          {
            "name": "Outbound connection restrictions"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Network egress monitoring and filtering"
          },
          {
            "name": "Anomalous network behavior detection"
          }
        ]
      }
    },
    {
      "id": "T-E013",
      "name": "Hidden VNC (HVNC) Deployment",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker deploys hidden Virtual Network Computing that provides invisible remote desktop access without user awareness",
      "risks": [
        "No EDR",
        "No process monitoring",
        "Lack of application sandboxing",
        "Privileged user accounts"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal local user privileges"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Process monitoring and whitelisting"
          },
          {
            "name": "Session activity monitoring"
          },
          {
            "name": "Behavioral analysis for hidden processes"
          },
          {
            "name": "Virtual desktop detection"
          }
        ]
      }
    },
    {
      "id": "T-E014",
      "name": "WebRTC P2P Control Channel Establishment",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker establishes WebRTC peer-to-peer connections for direct control that bypasses traditional firewalls via NAT traversal",
      "risks": [
        "WebRTC enabled in browsers/applications",
        "No network monitoring of WebRTC traffic",
        "NAT traversal bypasses firewall rules",
        "No EDR",
        "P2P connections not logged"
      ],
      "controls": {
        "protective": [
          {
            "name": "Network behavior analysis"
          },
          {
            "name": "WebRTC restrictions in corporate browsers"
          },
          {
            "name": "STUN/TURN server whitelisting"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "WebRTC traffic monitoring"
          },
          {
            "name": "Deep packet inspection"
          }
        ]
      }
    },
    {
      "id": "T-E015",
      "name": "Extension Auto-Update Exploitation",
      "component": "endpoint",
      "stage": "Initial Access",
      "description": "Attacker exploits automatic extension update mechanisms to silently deploy malicious updates to all users without interaction",
      "risks": [
        "Auto-updates enabled for extensions",
        "No update verification",
        "Compromised extension publisher accounts",
        "No extension version pinning",
        "Silent updates without user notification"
      ],
      "controls": {
        "protective": [
          {
            "name": "Extension update approval workflow"
          },
          {
            "name": "Extension version pinning"
          },
          {
            "name": "Update signature verification"
          },
          {
            "name": "Delayed update deployment (canary testing)"
          }
        ],
        "detective": [
          {
            "name": "Extension update monitoring and alerting"
          },
          {
            "name": "Extension marketplace security monitoring"
          }
        ]
      }
    },
    {
      "id": "T-E016",
      "name": "Blockchain-Based C2 Infrastructure",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker uses blockchain transactions (e.g., Solana, Bitcoin) as immutable command and control infrastructure that cannot be taken down or censored",
      "risks": [
        "Immutable C2 instructions on blockchain",
        "No EDR",
        "Cryptocurrency node connections not restricted"
      ],
      "controls": {
        "protective": [
          {
            "name": "Network behavior analysis"
          },
          {
            "name": "Cryptocurrency-related traffic restrictions"
          },
          {
            "name": "Application whitelisting"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Blockchain RPC connection monitoring"
          },
          {
            "name": "Anomalous blockchain query detection"
          }
        ]
      }
    },
    {
      "id": "T-E017",
      "name": "Legitimate Service Abuse for C2",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker uses legitimate cloud services (Google Calendar, Pastebin, social media, cloud storage) as command and control channels to evade detection",
      "risks": [
        "Legitimate services not monitored for C2 abuse",
        "No content inspection of legitimate service traffic",
        "Services whitelisted in security controls",
        "No EDR",
        "Encoded payloads in legitimate service data"
      ],
      "controls": {
        "protective": [
          {
            "name": "Deep content inspection of legitimate service traffic"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "Behavioral analysis for unusual service usage patterns"
          },
          {
            "name": "Network traffic anomaly detection"
          },
          {
            "name": "Application-level monitoring"
          },
          {
            "name": "Data exfiltration detection"
          }
        ]
      }
    },
    {
      "id": "T-E018",
      "name": "BitTorrent DHT for C2",
      "component": "endpoint",
      "stage": "Post-Compromise",
      "description": "Attacker uses BitTorrent Distributed Hash Table network for decentralized command distribution that cannot be shut down",
      "risks": [
        "BitTorrent/P2P traffic not monitored",
        "DHT network connections appear as normal P2P traffic",
        "No EDR",
        "Decentralized C2 cannot be taken down",
        "P2P protocols not restricted"
      ],
      "controls": {
        "protective": [
          {
            "name": "P2P protocol blocking"
          },
          {
            "name": "Network behavior analysis"
          },
          {
            "name": "Application whitelisting"
          }
        ],
        "detective": [
          {
            "name": "EDR on endpoint"
          },
          {
            "name": "BitTorrent traffic monitoring and blocking"
          },
          {
            "name": "DHT network connection detection"
          }
        ]
      }
    },
    {
      "id": "T-V001",
      "name": "Abuse Credentials for VCS Access",
      "component": "vcs",
      "stage": "Initial Access",
      "description": "Attacker uses stolen credentials to access VCS",
      "risks": [
        "Lack of 2FA / phishing protection",
        "Credentials in org public repos",
        "Credentials in public repos of org members",
        "Credentials in workflow logs",
        "Previous breaches",
        "Fine-grained PATs not enforced",
        "PATs without expiration"
      ],
      "controls": {
        "protective": [
          {
            "name": "Mandatory MFA"
          },
          {
            "name": "IDP / SSO setup"
          },
          {
            "name": "Enforcing fine-grained PATs"
          },
          {
            "name": "Enforcing PAT expiration"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning on org"
          },
          {
            "name": "Secret scanning on personal repos"
          }
        ]
      }
    },
    {
      "id": "T-V002",
      "name": "Imposter Commits",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker commits code impersonating another developer",
      "risks": [
        "No commit signing required",
        "Email verification not enforced",
        "No code review process"
      ],
      "controls": {
        "protective": [
          {
            "name": "Commit signing"
          },
          {
            "name": "Requiring code owner approval"
          },
          {
            "name": "Branch protection rules"
          },
          {
            "name": "Email verification enforcement"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-V003",
      "name": "Secret Exfiltration from Repo",
      "component": "vcs",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker extracts secrets from repository content or history",
      "risks": [
        "Misconfigured repo - visibility (public when should be private)",
        "Misconfigured VCS access - external contributors",
        "Using untrusted webhooks",
        "Dangling webhooks",
        "Secrets committed to repo"
      ],
      "controls": {
        "protective": [
          {
            "name": "Private repo visibility"
          },
          {
            "name": "Webhook security review"
          },
          {
            "name": "Branch protection rules"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning on org"
          },
          {
            "name": "Secret scanning on personal repos"
          },
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-V004",
      "name": "Secret Exfiltration from Personal Repo",
      "component": "vcs",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker finds secrets in personal repos of org members",
      "risks": [
        "Misconfigured repo - visibility",
        "Using personal repos for work",
        "Org members with public repos containing work content"
      ],
      "controls": {
        "protective": [
          {
            "name": "Policy against using personal repos for work"
          },
          {
            "name": "Security awareness training"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning on personal repos"
          },
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-V005",
      "name": "VCS Vulnerability Exploitation",
      "component": "vcs",
      "stage": "Initial Access",
      "description": "Attacker exploits vulnerability in VCS platform",
      "risks": [
        "Non-patched VCS instance",
        "Known CVEs not addressed",
        "Self-hosted VCS without security updates"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed VCS instances"
          },
          {
            "name": "Patching schedule"
          }
        ],
        "detective": [
          {
            "name": "Vulnerability scanning"
          },
          {
            "name": "Security update monitoring"
          }
        ]
      }
    },
    {
      "id": "T-V006",
      "name": "Turn Private Repos Public",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker changes repository visibility to public",
      "risks": [
        "Overprivileged VCS access",
        "No approval for visibility changes",
        "No audit log monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal VCS permissions"
          },
          {
            "name": "Approval workflow for visibility changes"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-V007",
      "name": "Clone Sensitive Repositories",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker clones private repositories to steal IP and source code",
      "risks": [
        "Overprivileged VCS access",
        "No audit log monitoring",
        "No DLP on network"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal VCS permissions"
          },
          {
            "name": "Repository access reviews"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs"
          },
          {
            "name": "Network DLP"
          }
        ]
      }
    },
    {
      "id": "T-V008",
      "name": "Malicious Repo Hosting",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker uses compromised VCS to host malicious repositories",
      "risks": [
        "Overprivileged VCS access",
        "No repository review process",
        "Unlimited repository creation"
      ],
      "controls": {
        "protective": [
          {
            "name": "Repository creation approval"
          },
          {
            "name": "Resource quotas"
          }
        ],
        "detective": [
          {
            "name": "Repository security scanning"
          },
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-V009",
      "name": "Mass Deletion of Repositories",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker deletes multiple repositories to cause data loss and operational disruption",
      "risks": [
        "Overprivileged VCS access",
        "No backup and recovery",
        "No audit log monitoring",
        "Insufficient access controls on critical repositories",
        "No repository deletion approval process",
        "Lack of deletion protection"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal VCS user permissions"
          },
          {
            "name": "Regular repository backups"
          },
          {
            "name": "Repository deletion approval workflow"
          },
          {
            "name": "Repository recovery procedures"
          },
          {
            "name": "Deletion protection on critical repositories"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (VCS)"
          },
          {
            "name": "Immutable audit logs"
          }
        ]
      }
    },
    {
      "id": "T-V010",
      "name": "Malicious Code Modification in Repository",
      "component": "vcs",
      "stage": "Post-Compromise",
      "description": "Attacker with repository access directly modifies source code to inject backdoors, malicious logic, or vulnerabilities into the codebase",
      "risks": [
        "Overprivileged VCS access",
        "No code review requirements",
        "Direct push to protected branches allowed",
        "Lack of commit signing",
        "No automated code security scanning",
        "Insufficient branch protection rules",
        "No detection of suspicious code patterns"
      ],
      "controls": {
        "protective": [
          {
            "name": "Branch protection rules (VCS)"
          },
          {
            "name": "Require code owner approval"
          },
          {
            "name": "Mandatory code review by multiple reviewers"
          },
          {
            "name": "Commit signing enforcement"
          },
          {
            "name": "Minimal VCS permissions (principle of least privilege)"
          },
          {
            "name": "Pre-commit hooks for security checks"
          }
        ],
        "detective": [
          {
            "name": "Automated code security scanning (SAST)"
          },
          {
            "name": "Detection infra on audit logs (VCS)"
          },
          {
            "name": "Code change anomaly detection"
          }
        ]
      }
    },
    {
      "id": "T-C001",
      "name": "Abuse Credentials for CI/CD Access",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker uses stolen credentials to access CI/CD system",
      "risks": [
        "Lack of 2FA / phishing protection",
        "Default credentials / bad out-of-the-box config",
        "Credentials in org public repos",
        "Previous breaches"
      ],
      "controls": {
        "protective": [
          {
            "name": "Mandatory MFA"
          },
          {
            "name": "IDP / SSO setup"
          },
          {
            "name": "Enforcing fine-grained PATs (VCS)"
          },
          {
            "name": "Enforcing PAT expiration (VCS)"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-C002",
      "name": "Malicious Execution in Workflow Context",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker executes malicious code within CI/CD workflow",
      "risks": [
        "Using untrusted GitHub actions",
        "Using untrusted GitHub Apps",
        "Using untrusted reusable workflows",
        "Using untrusted SW packages on runners",
        "Using untrusted container / VM image for runners",
        "Lack of GitHub action pinning"
      ],
      "controls": {
        "protective": [
          {
            "name": "Pinning 3rd-party actions"
          },
          {
            "name": "Action whitelisting"
          },
          {
            "name": "Automated maintainer reputation and hygiene checks"
          },
          {
            "name": "Requiring code owner approval (VCS)"
          },
          {
            "name": "Branch protection rules (VCS)"
          },
          {
            "name": "Runner SBOM"
          }
        ],
        "detective": [
          {
            "name": "Image scanning"
          }
        ]
      }
    },
    {
      "id": "T-C003",
      "name": "PWN Request / Poisoned Pipeline Execution",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker submits malicious PR that triggers workflow with elevated privileges",
      "risks": [
        "Misconfigured repo - visibility",
        "Misconfigured VCS access - external contributors",
        "Allowing PRs from forks",
        "Usage of pull_request_target/workflow_run",
        "Default workflow permissions set to WRITE",
        "Default workflow permissions set to approve PR",
        "Workflows with access to secrets"
      ],
      "controls": {
        "protective": [
          {
            "name": "Branch protection rules (VCS)"
          },
          {
            "name": "Private repo (VCS)"
          },
          {
            "name": "Require explicit approval/ disallow workflows from forks (VCS)"
          },
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Default workflow permissions not set to approve PRs"
          }
        ],
        "detective": [
          {
            "name": "CICD scanning tools"
          }
        ]
      }
    },
    {
      "id": "T-C004",
      "name": "Workflow Script Injection",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker injects malicious code into workflow through user-controlled input",
      "risks": [
        "Misconfigured repo - visibility",
        "Misconfigured workflow - script injection",
        "Default workflow permissions set to WRITE",
        "Default workflow permissions set to approve PR",
        "Workflow with excessive permissions",
        "Workflow with access to secrets"
      ],
      "controls": {
        "protective": [
          {
            "name": "Branch protection rules (VCS)"
          },
          {
            "name": "Private repo (VCS)"
          },
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Code review for workflows"
          }
        ],
        "detective": [
          {
            "name": "CICD scanning tools"
          }
        ]
      }
    },
    {
      "id": "T-C005",
      "name": "Secret Exfiltration from Workflow",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker extracts secrets from CI/CD workflow execution",
      "risks": [
        "Workflow with access to secrets",
        "No runtime monitoring",
        "Secrets in workflow logs",
        "Overprivileged secrets"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC setup in workflows"
          },
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Log sanitization"
          }
        ],
        "detective": [
          {
            "name": "Runtime agent on runner"
          },
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-C006",
      "name": "Secret Enumeration in Workflows Using GitHub Search",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker searches public workflows for exposed secrets",
      "risks": [
        "Workflow with access to secrets",
        "Public repositories",
        "Secrets in workflow files"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC setup in workflows"
          },
          {
            "name": "Private repositories"
          },
          {
            "name": "Code review for workflows"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-C007",
      "name": "Action Cache Poisoning",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker poisons shared action cache to inject malicious code",
      "risks": [
        "Shared actions cache",
        "No cache isolation",
        "No cache verification"
      ],
      "controls": {
        "protective": [
          {
            "name": "Don't use actions cache"
          },
          {
            "name": "Workflow ordering"
          },
          {
            "name": "Cache artifact signing / verification"
          },
          {
            "name": "Cache isolation per repository"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-C008",
      "name": "Malicious Workflow Performing Code Modification",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker uses workflow to modify code or approve PRs",
      "risks": [
        "Default workflow permissions set to WRITE",
        "Default workflow permissions set to approve PR",
        "Workflow with excessive permissions"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Default workflow permissions not set to approve PRs"
          },
          {
            "name": "Code review requirements"
          }
        ],
        "detective": [
          {
            "name": "CICD scanning tools"
          }
        ]
      }
    },
    {
      "id": "T-C009",
      "name": "CI/CD Vulnerability Exploitation",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker exploits vulnerability in CI/CD platform",
      "risks": [
        "Non-patched CI/CD instance",
        "Known CVEs not addressed",
        "Self-hosted CI/CD without security updates"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed CI/CD instances"
          },
          {
            "name": "Patching schedule"
          }
        ],
        "detective": [
          {
            "name": "Vulnerability scanning"
          },
          {
            "name": "Security update monitoring"
          }
        ]
      }
    },
    {
      "id": "T-C010",
      "name": "Runner Executing Malicious Package",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Malicious package executes on CI/CD runner",
      "risks": [
        "Using untrusted SW packages on runners",
        "No package verification",
        "No runtime monitoring",
        "Package installation scripts enabled",
        "Direct downloads from public registries"
      ],
      "controls": {
        "protective": [
          {
            "name": "Local registry proxy with filtering"
          },
          {
            "name": "Runner SBOM"
          },
          {
            "name": "Package version pinning"
          },
          {
            "name": "Package signature verification"
          },
          {
            "name": "Disable package installation scripts (--ignore-scripts)"
          }
        ],
        "detective": [
          {
            "name": "Runtime agent on runner"
          }
        ]
      }
    },
    {
      "id": "T-C011",
      "name": "Stealing Registry Tokens",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker extracts registry publishing tokens from workflow",
      "risks": [
        "Workflow with access to secrets",
        "Overprivileged registry tokens",
        "Long-lived credentials"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC setup in workflows"
          },
          {
            "name": "Trusted publishing (registry)"
          }
        ],
        "detective": [
          {
            "name": "Runtime agent on runner"
          },
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-C012",
      "name": "PR from Malicious Workflow",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Workflow creates malicious pull request",
      "risks": [
        "Default workflow permissions set to WRITE",
        "Default workflow permissions set to approve PR",
        "No PR review requirements"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Branch protection rules (VCS)"
          },
          {
            "name": "Require code owner approval (VCS)"
          }
        ],
        "detective": [
          {
            "name": "CICD scanning tools"
          }
        ]
      }
    },
    {
      "id": "T-C013",
      "name": "Persistence on Self-Hosted Runners",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker establishes persistence on self-hosted runner",
      "risks": [
        "Misconfigured self-hosted runner",
        "Non-ephemeral self-hosted runner",
        "Overshared self-hosted runner",
        "No runtime monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed runners only"
          },
          {
            "name": "Ephemeral runners"
          },
          {
            "name": "Runner isolation"
          }
        ],
        "detective": [
          {
            "name": "Runtime agent on runner"
          }
        ]
      }
    },
    {
      "id": "T-C014",
      "name": "Cryptomining on Runners",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker uses runner resources for cryptocurrency mining",
      "risks": [
        "No runtime monitoring",
        "No resource limits",
        "Self-hosted runners"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed runners only"
          }
        ],
        "detective": [
          {
            "name": "Runtime agent on runner"
          },
          {
            "name": "Resource monitoring and limits"
          },
          {
            "name": "Network monitoring"
          }
        ]
      }
    },
    {
      "id": "T-C015",
      "name": "Harvest Secrets from Workflows Using ${{toJson(secrets)}}",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses toJson() to dump all secrets from workflow",
      "risks": [
        "Workflow with access to secrets",
        "No CICD scanning",
        "No runtime monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC setup in workflows"
          },
          {
            "name": "Minimal workflow permissions"
          }
        ],
        "detective": [
          {
            "name": "CICD scanning tools"
          },
          {
            "name": "Runtime agent on runner"
          }
        ]
      }
    },
    {
      "id": "T-C016",
      "name": "Pivot from Self-Hosted VM Runner into Local Network / Cloud",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses runner network access to pivot into production",
      "risks": [
        "Overprivileged runner pod identity",
        "Misconfigured runner cluster",
        "Self-hosted runner in production network",
        "No network segmentation"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal runner pod privileges"
          },
          {
            "name": "Network segmentation"
          },
          {
            "name": "Using managed runners only"
          }
        ],
        "detective": [
          {
            "name": "K8s sensor on runner cluster"
          },
          {
            "name": "KSPM on runner cluster"
          }
        ]
      }
    },
    {
      "id": "T-C017",
      "name": "Pivot from Self-Hosted Container Runner into K8s Cluster",
      "component": "cicd",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker escapes container runner to access Kubernetes cluster",
      "risks": [
        "Overprivileged runner pod identity",
        "Misconfigured runner cluster",
        "No pod security policies",
        "Privileged containers allowed"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal runner pod privileges"
          },
          {
            "name": "Pod security policies"
          },
          {
            "name": "Using managed runners only"
          }
        ],
        "detective": [
          {
            "name": "K8s sensor on runner cluster"
          },
          {
            "name": "KSPM on runner cluster"
          }
        ]
      }
    },
    {
      "id": "T-C018",
      "name": "Data Exfiltration from CI/CD",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker exfiltrates build artifacts, logs, secrets, and sensitive data from CI/CD system over network",
      "risks": [
        "No network egress monitoring",
        "Unrestricted outbound network access from runners",
        "Build artifacts contain sensitive data",
        "Logs contain secrets or sensitive information",
        "No DLP on CI/CD network"
      ],
      "controls": {
        "protective": [
          {
            "name": "Log sanitization"
          },
          {
            "name": "Artifact encryption"
          },
          {
            "name": "Network segmentation (CI/CD from internet)"
          }
        ],
        "detective": [
          {
            "name": "Network DLP"
          },
          {
            "name": "Egress traffic monitoring and filtering"
          },
          {
            "name": "Runtime agent on runner"
          },
          {
            "name": "Large data transfer detection"
          },
          {
            "name": "Detection infra on audit logs (CI/CD)"
          }
        ]
      }
    },
    {
      "id": "T-C019",
      "name": "CI/CD Infrastructure Destruction",
      "component": "cicd",
      "stage": "Post-Compromise",
      "description": "Attacker destroys CI/CD pipelines, workflows, runners, or build artifacts to disrupt development and deployment operations",
      "risks": [
        "Overprivileged workflow permissions",
        "No backup and recovery",
        "Lack of workflow protection",
        "No audit log monitoring",
        "Insufficient access controls on critical workflows",
        "No approval process for infrastructure changes"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Regular CI/CD configuration backups"
          },
          {
            "name": "Workflow protection rules"
          },
          {
            "name": "Infrastructure change approval workflow"
          },
          {
            "name": "CI/CD recovery procedures"
          },
          {
            "name": "Using managed runners only"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (CI/CD)"
          },
          {
            "name": "Immutable audit logs"
          }
        ]
      }
    },
    {
      "id": "T-C020",
      "name": "CI/CD Misconfiguration Exploitation",
      "component": "cicd",
      "stage": "Initial Access",
      "description": "Attacker exploits misconfiguration in CI/CD platform",
      "risks": [
        "Misconfigured CI/CD instances"
      ],
      "controls": {
        "protective": [
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-R001",
      "name": "Abuse Credentials for Registry Access",
      "component": "registry",
      "stage": "Initial Access",
      "description": "Attacker uses stolen credentials to access registry",
      "risks": [
        "Lack of 2FA / phishing protection",
        "Default credentials / bad out-of-the-box config",
        "Credentials in public images",
        "Credentials in workflow logs",
        "Previous breaches"
      ],
      "controls": {
        "protective": [
          {
            "name": "Mandatory MFA"
          },
          {
            "name": "IDP / SSO setup"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-R002",
      "name": "Misconfigured / Anonymous Access",
      "component": "registry",
      "stage": "Initial Access",
      "description": "Attacker exploits misconfigured registry permissions",
      "risks": [
        "Misconfigured registry access",
        "Anonymous access enabled",
        "Overly permissive access controls"
      ],
      "controls": {
        "protective": [
          {
            "name": "IDP / SSO setup"
          },
          {
            "name": "Access control reviews"
          },
          {
            "name": "Principle of least privilege"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-R003",
      "name": "Registry Vulnerability Exploitation",
      "component": "registry",
      "stage": "Initial Access",
      "description": "Attacker exploits vulnerability in registry platform",
      "risks": [
        "Non-patched artifact/container registry",
        "Known CVEs not addressed",
        "Self-hosted registry without security updates"
      ],
      "controls": {
        "protective": [
          {
            "name": "Using managed registry instances"
          },
          {
            "name": "Patching schedule"
          }
        ],
        "detective": [
          {
            "name": "Vulnerability scanning"
          },
          {
            "name": "Security update monitoring"
          }
        ]
      }
    },
    {
      "id": "T-R004",
      "name": "Publishing Malicious Package",
      "component": "registry",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker publishes malicious package to registry",
      "risks": [
        "Overprivileged NPM token",
        "Lack of provenance",
        "Lack of trusted publishing",
        "No package signing"
      ],
      "controls": {
        "protective": [
          {
            "name": "Trusted publishing"
          },
          {
            "name": "Provenance attestation"
          },
          {
            "name": "MFA for registry account"
          },
          {
            "name": "Package signing and verification"
          },
          {
            "name": "OIDC for publishing"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-R005",
      "name": "Publishing Malicious Container/VM Image",
      "component": "registry",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker publishes malicious container or VM image",
      "risks": [
        "Overprivileged registry credentials",
        "No image signing",
        "No provenance attestation",
        "No image scanning"
      ],
      "controls": {
        "protective": [
          {
            "name": "Trusted publishing"
          },
          {
            "name": "Provenance attestation"
          },
          {
            "name": "Image signing and verification"
          },
          {
            "name": "OIDC for publishing"
          }
        ],
        "detective": [
          {
            "name": "Image vulnerability scanning"
          }
        ]
      }
    },
    {
      "id": "T-R006",
      "name": "Publishing Malicious IDE/Browser Extension",
      "component": "registry",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker publishes malicious extension to extension marketplace",
      "risks": [
        "Overprivileged publishing credentials",
        "No extension review process",
        "No signing requirements"
      ],
      "controls": {
        "protective": [
          {
            "name": "Extension signing requirements"
          },
          {
            "name": "Extension review process"
          },
          {
            "name": "MFA for publisher account"
          },
          {
            "name": "Trusted publishing"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-R007",
      "name": "Harvest Data from Private Artifacts",
      "component": "registry",
      "stage": "Post-Compromise",
      "description": "Attacker extracts sensitive data from private artifacts",
      "risks": [
        "Overprivileged registry access",
        "Secrets in artifacts",
        "No audit log monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal registry permissions"
          },
          {
            "name": "Artifact encryption"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          },
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-R008",
      "name": "Malicious Images Hosting",
      "component": "registry",
      "stage": "Post-Compromise",
      "description": "Attacker uses compromised registry to host malicious images",
      "risks": [
        "Overprivileged registry access",
        "No image scanning",
        "No resource quotas"
      ],
      "controls": {
        "protective": [
          {
            "name": "Resource quotas"
          },
          {
            "name": "Access control reviews"
          }
        ],
        "detective": [
          {
            "name": "Image vulnerability scanning"
          },
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-R009",
      "name": "Registry Infrastructure Destruction",
      "component": "registry",
      "stage": "Post-Compromise",
      "description": "Attacker deletes packages, images, or corrupts registry infrastructure to disrupt software distribution and deployment",
      "risks": [
        "Overprivileged registry access",
        "No backup and recovery",
        "Lack of deletion protection",
        "No audit log monitoring",
        "Insufficient access controls on critical artifacts",
        "No artifact deletion approval process"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal user permissions (registry)"
          },
          {
            "name": "Regular artifact backups"
          },
          {
            "name": "Artifact deletion protection"
          },
          {
            "name": "Artifact deletion approval workflow"
          },
          {
            "name": "Immutable artifact storage"
          },
          {
            "name": "Registry recovery procedures"
          },
          {
            "name": "Artifact retention policies"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (registry)"
          }
        ]
      }
    },
    {
      "id": "T-R010",
      "name": "Typosquatting",
      "component": "registry",
      "stage": "Initial Access",
      "description": "Attacker publishes malicious packages with names similar to legitimate ones to trick developers into installing them by mistake",
      "risks": [
        "No package name verification",
        "Lack of typosquatting detection",
        "Developer mistakes during package installation",
        "No package naming policies",
        "Lack of security awareness training",
        "Direct downloads from public registries"
      ],
      "controls": {
        "protective": [
          {
            "name": "Local registry proxy with filtering"
          },
          {
            "name": "Package name similarity checks"
          },
          {
            "name": "Automated maintainer reputation and hygiene checks"
          },
          {
            "name": "Security awareness training on package verification"
          },
          {
            "name": "Package installation verification workflows"
          },
          {
            "name": "Dependency review and approval process"
          },
          {
            "name": "Package popularity and reputation scoring"
          }
        ],
        "detective": [
          {
            "name": "Typosquatting detection and prevention"
          }
        ]
      }
    },
    {
      "id": "T-R011",
      "name": "Namespace/Dependency Confusion",
      "component": "registry",
      "stage": "Initial Access",
      "description": "Attacker publishes malicious packages with same names as private packages but higher version numbers, tricking package managers into fetching the public version instead of the private package",
      "risks": [
        "Lack of internal repository enforcement",
        "Package managers prioritize public repositories",
        "No namespace isolation between internal and public packages",
        "Automatic dependency resolution without verification",
        "Higher version numbers in public repositories",
        "Direct downloads from public registries"
      ],
      "controls": {
        "protective": [
          {
            "name": "Local registry proxy with filtering"
          },
          {
            "name": "Internal repository enforcement and prioritization"
          },
          {
            "name": "Namespace isolation and scoping"
          },
          {
            "name": "Package version pinning"
          },
          {
            "name": "Automated maintainer reputation and hygiene checks"
          },
          {
            "name": "Private package registry configuration"
          },
          {
            "name": "Dependency resolution policies"
          },
          {
            "name": "Package source verification"
          }
        ],
        "detective": []
      }
    },
    {
      "id": "T-P001",
      "name": "Abuse Production Credentials from CI/CD",
      "component": "production",
      "stage": "Initial Access",
      "description": "Attacker extracts production credentials from CI/CD and uses them to access production",
      "risks": [
        "Production credentials in CI/CD workflows",
        "Long-lived production credentials",
        "Overprivileged cloud service accounts",
        "No credential rotation"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC for deployment (no long-lived credentials)"
          },
          {
            "name": "Minimal IAM permissions"
          },
          {
            "name": "Credential rotation"
          },
          {
            "name": "Network segmentation from SDLC"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          }
        ]
      }
    },
    {
      "id": "T-P002",
      "name": "Malicious Deployment via Compromised Pipeline",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker modifies CI/CD pipeline to deploy malicious code to production",
      "risks": [
        "No deployment approval gates",
        "Overprivileged deployment credentials",
        "No code signing verification",
        "Insufficient workflow permissions review"
      ],
      "controls": {
        "protective": [
          {
            "name": "Deployment approval gates"
          },
          {
            "name": "Code signing and verification"
          },
          {
            "name": "Minimal workflow permissions"
          },
          {
            "name": "Branch protection rules (VCS)"
          }
        ],
        "detective": [
          {
            "name": "Deployment monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P003",
      "name": "Pivot from Self-Hosted Runner to Production Network",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses self-hosted runner network access to pivot into production",
      "risks": [
        "Self-hosted runner in production network",
        "Weak network segmentation",
        "Overprivileged runner identity",
        "No network monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Network segmentation from SDLC"
          },
          {
            "name": "Using managed runners only"
          },
          {
            "name": "Runner isolation"
          },
          {
            "name": "Minimal runner privileges"
          }
        ],
        "detective": [
          {
            "name": "Network monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P004",
      "name": "Container Image Poisoning to Production",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker publishes malicious container image that gets deployed to production",
      "risks": [
        "Lack of image signing/verification",
        "No provenance attestation",
        "Automatic deployment without review",
        "No image scanning"
      ],
      "controls": {
        "protective": [
          {
            "name": "Image signing and verification"
          },
          {
            "name": "Provenance attestation"
          },
          {
            "name": "Deployment approval gates"
          }
        ],
        "detective": [
          {
            "name": "Image vulnerability scanning"
          },
          {
            "name": "Runtime security monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P005",
      "name": "Infrastructure-as-Code Manipulation",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker modifies IaC to create backdoors in production infrastructure",
      "risks": [
        "Insufficient IaC review process",
        "Lack of drift detection",
        "Overprivileged deployment credentials"
      ],
      "controls": {
        "protective": [
          {
            "name": "Code review for IaC changes"
          },
          {
            "name": "Deployment approval gates"
          },
          {
            "name": "Minimal deployment permissions"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Drift detection"
          }
        ]
      }
    },
    {
      "id": "T-P006",
      "name": "Kubernetes Service Account Token Theft",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker extracts Kubernetes service account tokens from CI/CD",
      "risks": [
        "Overprivileged service accounts",
        "Long-lived tokens",
        "Lack of token rotation",
        "Tokens in CI/CD secrets"
      ],
      "controls": {
        "protective": [
          {
            "name": "OIDC for K8s access"
          },
          {
            "name": "Minimal service account permissions"
          },
          {
            "name": "Token rotation"
          }
        ],
        "detective": [
          {
            "name": "Secret scanning"
          },
          {
            "name": "Runtime security monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P007",
      "name": "Cloud Metadata Service Exploitation",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker accesses cloud metadata service to steal additional credentials",
      "risks": [
        "Metadata service not restricted",
        "Overprivileged IAM roles",
        "No network segmentation",
        "Compromised workload with metadata access"
      ],
      "controls": {
        "protective": [
          {
            "name": "Metadata service restrictions"
          },
          {
            "name": "Minimal IAM permissions"
          },
          {
            "name": "Network segmentation"
          },
          {
            "name": "IMDSv2 enforcement (AWS)"
          }
        ],
        "detective": [
          {
            "name": "Runtime security monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P008",
      "name": "Kubernetes Pod Escape",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker escapes from container to underlying node",
      "risks": [
        "Privileged containers allowed",
        "No pod security policies",
        "Overprivileged pod identity",
        "Host filesystem mounted"
      ],
      "controls": {
        "protective": [
          {
            "name": "Pod security policies"
          },
          {
            "name": "Minimal pod privileges"
          }
        ],
        "detective": [
          {
            "name": "K8s sensor on cluster"
          },
          {
            "name": "KSPM"
          },
          {
            "name": "Runtime security monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P009",
      "name": "Cloud Service Lateral Movement",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker uses compromised cloud credentials to access other cloud services",
      "risks": [
        "Overprivileged IAM roles",
        "No network segmentation",
        "Lack of service-to-service authentication",
        "No audit log monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal IAM permissions"
          },
          {
            "name": "Network segmentation"
          },
          {
            "name": "Service mesh / zero trust"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs"
          }
        ]
      }
    },
    {
      "id": "T-P010",
      "name": "Network Lateral Movement Within Production",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker moves between production systems via network",
      "risks": [
        "Weak network segmentation",
        "Overly permissive security groups",
        "No network monitoring",
        "Unpatched systems"
      ],
      "controls": {
        "protective": [
          {
            "name": "Network segmentation"
          },
          {
            "name": "Micro-segmentation"
          },
          {
            "name": "Security group hardening"
          },
          {
            "name": "Vulnerability management"
          }
        ],
        "detective": [
          {
            "name": "Network monitoring"
          }
        ]
      }
    },
    {
      "id": "T-P011",
      "name": "Steal Secrets from Production Environment",
      "component": "production",
      "stage": "Post-Compromise",
      "description": "Attacker accesses production secrets store and exfiltrates customer secrets, tokens, and credentials",
      "risks": [
        "Encryption keys accessible in process memory",
        "Lack of hardware security module (HSM) for key storage",
        "No secrets rotation policies",
        "Centralized storage of all customer secrets",
        "No data loss prevention (DLP) on production systems",
        "Lack of egress traffic monitoring"
      ],
      "controls": {
        "protective": [
          {
            "name": "Store encryption keys in HSM (Hardware Security Module)"
          },
          {
            "name": "Envelope encryption with key hierarchy"
          },
          {
            "name": "Customer-managed encryption keys (CMEK)"
          },
          {
            "name": "Automatic secrets rotation (30-90 days)"
          },
          {
            "name": "Secrets segmentation (per-customer isolation)"
          },
          {
            "name": "Memory protection and anti-dumping controls"
          }
        ],
        "detective": [
          {
            "name": "DLP on production systems"
          },
          {
            "name": "Egress traffic monitoring and filtering"
          },
          {
            "name": "Detection infra on audit logs (production)"
          },
          {
            "name": "Large data transfer detection"
          }
        ]
      }
    },
    {
      "id": "T-P012",
      "name": "Production Infrastructure Reconnaissance",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker enumerates production infrastructure, services, and resources to identify targets and plan attacks",
      "risks": [
        "Overprivileged IAM roles allowing enumeration",
        "No detection of reconnaissance activities",
        "Publicly exposed cloud metadata",
        "Insufficient network segmentation allowing scanning",
        "Verbose error messages revealing infrastructure details",
        "Lack of honeypots or deception technology",
        "No rate limiting on API calls"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal IAM permissions"
          },
          {
            "name": "API rate limiting and throttling"
          },
          {
            "name": "Network segmentation (production internal)"
          },
          {
            "name": "Metadata service restrictions"
          },
          {
            "name": "Generic error messages (no infrastructure details)"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (production)"
          },
          {
            "name": "Honeypots and deception technology"
          },
          {
            "name": "Anomaly detection for enumeration patterns"
          }
        ]
      }
    },
    {
      "id": "T-P013",
      "name": "Data Exfiltration from Production",
      "component": "production",
      "stage": "Post-Compromise",
      "description": "Attacker exfiltrates customer data, application data, databases, and sensitive information from production environment over network",
      "risks": [
        "No network egress monitoring",
        "Unrestricted outbound network access",
        "No DLP on production systems",
        "Backup data accessible and unmonitored",
        "Use of encrypted channels to bypass DLP",
        "Cloud storage buckets with public access"
      ],
      "controls": {
        "protective": [
          {
            "name": "Backup encryption and access controls"
          },
          {
            "name": "SSL/TLS inspection"
          },
          {
            "name": "Data classification and handling policies"
          },
          {
            "name": "Network segmentation (production from internet)"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Network DLP"
          },
          {
            "name": "Egress traffic monitoring and filtering"
          },
          {
            "name": "Large data transfer detection"
          },
          {
            "name": "Database activity monitoring"
          },
          {
            "name": "Detection infra on audit logs (production)"
          }
        ]
      }
    },
    {
      "id": "T-P014",
      "name": "Production Infrastructure Destruction",
      "component": "production",
      "stage": "Post-Compromise",
      "description": "Attacker destroys production infrastructure, databases, storage, or configurations to cause severe operational disruption and data loss",
      "risks": [
        "Overprivileged IAM roles allowing destructive actions",
        "No backup and disaster recovery plan",
        "Lack of deletion protection on critical resources",
        "No audit log monitoring",
        "Insufficient access controls on critical infrastructure",
        "No approval process for destructive operations",
        "Backup data not isolated from production"
      ],
      "controls": {
        "protective": [
          {
            "name": "Minimal IAM permissions"
          },
          {
            "name": "Regular backups with offsite/offline storage"
          },
          {
            "name": "Deletion protection on critical resources"
          },
          {
            "name": "Destructive operation approval workflow"
          },
          {
            "name": "Immutable backups"
          },
          {
            "name": "Disaster recovery procedures and testing"
          },
          {
            "name": "Resource tagging and protection policies"
          },
          {
            "name": "Backup isolation from production network"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (production)"
          }
        ]
      }
    },
    {
      "id": "T-P015",
      "name": "Malicious Service Provisioning for Persistence",
      "component": "production",
      "stage": "Post-Compromise",
      "description": "Attacker provisions new malicious services or backdoors existing services in orchestration platform (e.g., ArgoCD, Kubernetes) to establish persistence",
      "risks": [
        "No approval gates for service provisioning",
        "Developers can create arbitrary services",
        "Service definitions not audited",
        "No anomaly detection for new service creation",
        "Persistent backdoor services remain undetected"
      ],
      "controls": {
        "protective": [
          {
            "name": "Deployment approval gates for new services"
          },
          {
            "name": "Code review for all IaC changes"
          },
          {
            "name": "Baseline approved services list"
          },
          {
            "name": "CSPM/CNAPP"
          }
        ],
        "detective": [
          {
            "name": "Detection infra on audit logs (production)"
          },
          {
            "name": "Anomaly detection for new service creation patterns"
          },
          {
            "name": "Immutable audit logs"
          },
          {
            "name": "Regular service inventory audits"
          }
        ]
      }
    },
    {
      "id": "T-P016",
      "name": "Supply Chain Backdoor (Sensor/Agent Poisoning)",
      "component": "production",
      "stage": "Discovery and Lateral Movement",
      "description": "Attacker injects backdoor into security sensors, agents, or client-distributed software, causing downstream supply chain compromise affecting all customers",
      "risks": [
        "No binary signing verification for distributed software",
        "Customer updates automatically deployed without verification",
        "No provenance attestation for sensor binaries",
        "No multi-party approval for releases"
      ],
      "controls": {
        "protective": [
          {
            "name": "Code signing and verification for all distributed binaries"
          },
          {
            "name": "Provenance attestation (SLSA Level 3+)"
          },
          {
            "name": "Customer-controlled update policies with verification"
          },
          {
            "name": "Separation of duties for release signing"
          },
          {
            "name": "Immutable build logs and attestations"
          }
        ],
        "detective": [
          {
            "name": "Multi-party approval for sensor/agent releases"
          },
          {
            "name": "Regular security audits of build infrastructure"
          }
        ]
      }
    }
  ]
};
        
        // Component color mapping (presentation layer)
        const componentColors = {
            'endpoint': '#3B82F6',
            'vcs': '#10B981',
            'cicd': '#F59E0B',
            'registry': '#8B5CF6',
            'production': '#EF4444'
        };
        
        // Custom Node Components
        const EntryPointNode = ({ data, id }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [label, setLabel] = useState(data.label);
            const inputRef = useRef(null);
            
            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                }
            }, [isEditing]);
            
            const handleDoubleClick = () => {
                setIsEditing(true);
            };
            
            const handleBlur = () => {
                setIsEditing(false);
                if (label.trim()) {
                    data.label = label.trim();
                } else {
                    setLabel(data.label);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleBlur();
                } else if (e.key === 'Escape') {
                    setLabel(data.label);
                    setIsEditing(false);
                }
            };
            
            return (
                <div className="entry-exit-node border-2 border-dashed" style={{
                    backgroundColor: 'rgba(16, 185, 129, 0.15)',
                    borderColor: 'var(--wiz-success)',
                    color: 'var(--wiz-success)'
                }}>
                    {isEditing ? (
                        <input
                            ref={inputRef}
                            type="text"
                            value={label}
                            onChange={(e) => setLabel(e.target.value)}
                            onBlur={handleBlur}
                            onKeyDown={handleKeyDown}
                            className="font-semibold bg-transparent border-none outline-none w-full text-center"
                            style={{ minWidth: '100px', color: 'var(--wiz-success)' }}
                        />
                    ) : (
                        <div
                            className="font-semibold cursor-pointer"
                            onDoubleClick={handleDoubleClick}
                            title="Double-click to edit"
                        >
                             {label}
                        </div>
                    )}
                    <Handle type="source" position={Position.Right} id="right" style={{ top: '50%' }} />
                    <Handle type="source" position={Position.Bottom} id="bottom" style={{ left: '50%' }} />
                </div>
            );
        };
        
        const ExitPointNode = ({ data, id }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [label, setLabel] = useState(data.label);
            const inputRef = useRef(null);
            
            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                }
            }, [isEditing]);
            
            const handleDoubleClick = () => {
                setIsEditing(true);
            };
            
            const handleBlur = () => {
                setIsEditing(false);
                if (label.trim()) {
                    data.label = label.trim();
                } else {
                    setLabel(data.label);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleBlur();
                } else if (e.key === 'Escape') {
                    setLabel(data.label);
                    setIsEditing(false);
                }
            };
            
            return (
                <div className="entry-exit-node border-2 border-solid" style={{
                    backgroundColor: 'rgba(239, 68, 68, 0.15)',
                    borderColor: 'var(--wiz-danger)',
                    color: 'var(--wiz-danger)'
                }}>
                    <Handle type="target" position={Position.Left} id="left" style={{ top: '50%' }} />
                    <Handle type="target" position={Position.Top} id="top" style={{ left: '50%' }} />
                    {isEditing ? (
                        <input
                            ref={inputRef}
                            type="text"
                            value={label}
                            onChange={(e) => setLabel(e.target.value)}
                            onBlur={handleBlur}
                            onKeyDown={handleKeyDown}
                            className="font-semibold bg-transparent border-none outline-none w-full text-center"
                            style={{ minWidth: '100px', color: 'var(--wiz-danger)' }}
                        />
                    ) : (
                        <div
                            className="font-semibold cursor-pointer"
                            onDoubleClick={handleDoubleClick}
                            title="Double-click to edit"
                        >
                             {label}
                        </div>
                    )}
                </div>
            );
        };
        
        const ComponentNode = ({ data, selected, id }) => {
            const component = techniquesData?.components.find(c => c.id === data.componentId);
            const bgColor = componentColors[data.componentId] || '#6B7280';
            const [isEditing, setIsEditing] = useState(false);
            const [customLabel, setCustomLabel] = useState(data.customLabel || '');
            const inputRef = useRef(null);
            
            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                }
            }, [isEditing]);
            
            const handleDoubleClick = (e) => {
                e.stopPropagation();
                setIsEditing(true);
            };
            
            const handleBlur = () => {
                setIsEditing(false);
                data.customLabel = customLabel.trim();
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleBlur();
                } else if (e.key === 'Escape') {
                    setCustomLabel(data.customLabel || '');
                    setIsEditing(false);
                }
            };
            
            const displayName = component?.name || data.label;
            const displayLabel = customLabel || data.customLabel;
            
            return (
                <>
                    <NodeResizer
                        isVisible={selected}
                        minWidth={200}
                        minHeight={150}
                    />
                    <div className="component-node" style={{
                        border: `2px solid ${bgColor}`,
                        backgroundColor: 'var(--wiz-dark-surface)',
                        width: '100%',
                        height: '100%',
                        display: 'flex',
                        flexDirection: 'column'
                    }}>
                        {/* No connection handles for architectural components */}
                        
                        <div className="p-3 border-b" style={{
                            flexShrink: 0,
                            background: 'rgba(74, 144, 226, 0.1)',
                            borderColor: 'var(--wiz-dark-border)'
                        }}>
                            <div className="font-bold text-sm" style={{ color: bgColor }}>
                                {displayName}
                            </div>
                            {isEditing ? (
                                <input
                                    ref={inputRef}
                                    type="text"
                                    value={customLabel}
                                    onChange={(e) => setCustomLabel(e.target.value)}
                                    onBlur={handleBlur}
                                    onKeyDown={handleKeyDown}
                                    placeholder="e.g., Producer, Consumer"
                                    className="mt-1 text-xs bg-transparent border-none outline-none w-full"
                                    style={{
                                        minWidth: '100px',
                                        color: 'var(--wiz-text-secondary)',
                                        borderBottom: '1px solid var(--wiz-accent-purple)'
                                    }}
                                />
                            ) : (
                                <div
                                    className="mt-1 text-xs cursor-pointer"
                                    onDoubleClick={handleDoubleClick}
                                    title="Double-click to add label (e.g., Producer/Consumer)"
                                    style={{
                                        color: displayLabel ? 'var(--wiz-text-secondary)' : 'var(--wiz-text-secondary)',
                                        fontStyle: displayLabel ? 'normal' : 'italic',
                                        opacity: displayLabel ? 1 : 0.5
                                    }}
                                >
                                    {displayLabel || 'Double-click to add label'}
                                </div>
                            )}
                        </div>
                        <div className="p-2 overflow-auto" style={{ flex: 1, backgroundColor: 'var(--wiz-dark-bg)' }}>
                            {/* Component container - techniques are placed as independent nodes on canvas */}
                        </div>
                    </div>
                </>
            );
        };
        
        const TechniqueNode = ({ data, id }) => {
            const component = techniquesData?.components.find(c => c.id === data.component);
            const bgColor = componentColors[data.component] || '#6B7280';
            const [showControls, setShowControls] = useState(false);
            const [showRisks, setShowRisks] = useState(false);
            const [isEditing, setIsEditing] = useState(false);
            const [customLabel, setCustomLabel] = useState(data.customLabel || '');
            const inputRef = useRef(null);
            
            // Find full technique data
            const fullTechnique = techniquesData?.techniques.find(t => t.id === data.id);
            
            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                }
            }, [isEditing]);
            
            const handleDoubleClick = (e) => {
                e.stopPropagation();
                setIsEditing(true);
            };
            
            const handleBlur = () => {
                setIsEditing(false);
                data.customLabel = customLabel.trim();
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleBlur();
                } else if (e.key === 'Escape') {
                    setCustomLabel(data.customLabel || '');
                    setIsEditing(false);
                }
            };
            
            const displayLabel = customLabel || data.customLabel;
            
            return (
                <div style={{ position: 'relative', width: '160px' }}>
                    {/* Vertical connection handles only */}
                    <Handle type="target" position={Position.Top} id="top" style={{ left: '50%' }} />
                    <Handle type="source" position={Position.Bottom} id="bottom" style={{ left: '50%' }} />
                    
                    {/* Risks expansion button (LEFT - swapped) */}
                    <button
                        onClick={() => setShowRisks(!showRisks)}
                        style={{
                            position: 'absolute',
                            left: '-12px',
                            top: '50%',
                            transform: 'translateY(-50%)',
                            width: '24px',
                            height: '24px',
                            borderRadius: '50%',
                            border: '2px solid var(--wiz-danger)',
                            backgroundColor: 'var(--wiz-dark-surface)',
                            cursor: 'pointer',
                            fontSize: '14px',
                            lineHeight: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: 0,
                            zIndex: 10,
                            color: 'var(--wiz-danger)',
                            fontWeight: 'bold'
                        }}
                        title="Show Risks"
                    >
                        {showRisks ? '' : ''}
                    </button>
                    
                    {/* Controls expansion button (RIGHT - swapped) */}
                    <button
                        onClick={() => setShowControls(!showControls)}
                        style={{
                            position: 'absolute',
                            right: '-12px',
                            top: '50%',
                            transform: 'translateY(-50%)',
                            width: '24px',
                            height: '24px',
                            borderRadius: '50%',
                            border: '2px solid var(--wiz-success)',
                            backgroundColor: 'var(--wiz-dark-surface)',
                            cursor: 'pointer',
                            fontSize: '14px',
                            lineHeight: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: 0,
                            zIndex: 10,
                            color: 'var(--wiz-success)',
                            fontWeight: 'bold'
                        }}
                        title="Show Controls"
                    >
                        {showControls ? '' : ''}
                    </button>
                    
                    {/* Main technique card */}
                    <div className="p-2 border-2 rounded shadow-sm" style={{
                        borderColor: bgColor,
                        background: 'rgba(252, 128, 255, 0.08)'
                    }}>
                        <div className="text-xs font-bold mb-0.5" style={{ color: bgColor }}>
                            {data.id}
                        </div>
                        <div className="text-xs font-medium mb-2 line-clamp-2" style={{ color: 'var(--wiz-text-primary)' }}>
                            {data.name}
                        </div>
                        {isEditing ? (
                            <input
                                ref={inputRef}
                                type="text"
                                value={customLabel}
                                onChange={(e) => setCustomLabel(e.target.value)}
                                onBlur={handleBlur}
                                onKeyDown={handleKeyDown}
                                placeholder="e.g., Initial Access, Collection"
                                className="text-xs bg-transparent border-none outline-none w-full mt-1"
                                style={{
                                    minWidth: '100px',
                                    color: 'var(--wiz-text-secondary)',
                                    borderBottom: '1px solid var(--wiz-accent-purple)',
                                    paddingTop: '2px'
                                }}
                            />
                        ) : (
                            <div
                                className="text-xs cursor-pointer mt-1"
                                onDoubleClick={handleDoubleClick}
                                title="Double-click to add stage/context label"
                                style={{
                                    color: displayLabel ? 'var(--wiz-text-secondary)' : 'var(--wiz-text-secondary)',
                                    fontStyle: displayLabel ? 'normal' : 'italic',
                                    opacity: displayLabel ? 1 : 0.5,
                                    paddingTop: '2px',
                                    borderTop: displayLabel ? '1px solid var(--wiz-dark-border)' : 'none'
                                }}
                            >
                                {displayLabel || 'Double-click to label'}
                            </div>
                        )}
                    </div>
                    
                    {/* Risks popup (LEFT - swapped) */}
                    {showRisks && fullTechnique && (
                        <div className="technique-popup" style={{
                            right: '100%',
                            top: 0,
                            marginRight: '20px',
                            width: '200px',
                            backgroundColor: 'var(--wiz-dark-surface)',
                            border: '2px solid var(--wiz-danger)',
                            borderRadius: '4px',
                            padding: '8px',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.5)',
                            pointerEvents: 'auto'
                        }}>
                            <div style={{ fontSize: '11px', fontWeight: 'bold', color: 'var(--wiz-danger)', marginBottom: '4px' }}>
                                Risks
                            </div>
                            <ul style={{ fontSize: '10px', margin: 0, paddingLeft: '16px', color: 'var(--wiz-text-primary)' }}>
                                {fullTechnique.risks.map((risk, idx) => (
                                    <li key={idx} style={{ marginBottom: '2px' }}>{risk}</li>
                                ))}
                            </ul>
                        </div>
                    )}
                    
                    {/* Controls popup (RIGHT - swapped) */}
                    {showControls && fullTechnique && (
                        <div className="technique-popup" style={{
                            left: '100%',
                            top: 0,
                            marginLeft: '20px',
                            width: '200px',
                            backgroundColor: 'var(--wiz-dark-surface)',
                            border: '2px solid var(--wiz-success)',
                            borderRadius: '4px',
                            padding: '8px',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.5)',
                            pointerEvents: 'auto'
                        }}>
                            {(fullTechnique.controls?.protective || []).length > 0 && (
                                <>
                                    <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#10B981', marginBottom: '4px' }}>
                                         Protective
                                    </div>
                                    <ul style={{ fontSize: '10px', margin: 0, paddingLeft: '16px', color: 'var(--wiz-text-primary)', marginBottom: '8px' }}>
                                        {(fullTechnique.controls?.protective || []).map((control, idx) => (
                                            <li key={idx} style={{ marginBottom: '2px' }}>{control.name || control}</li>
                                        ))}
                                    </ul>
                                </>
                            )}
                            {(fullTechnique.controls?.detective || []).length > 0 && (
                                <>
                                    <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#F59E0B', marginBottom: '4px' }}>
                                         Detective
                                    </div>
                                    <ul style={{ fontSize: '10px', margin: 0, paddingLeft: '16px', color: 'var(--wiz-text-primary)' }}>
                                        {(fullTechnique.controls?.detective || []).map((control, idx) => (
                                            <li key={idx} style={{ marginBottom: '2px' }}>{control.name || control}</li>
                                        ))}
                                    </ul>
                                </>
                            )}
                        </div>
                    )}
                </div>
            );
        };
        
        const nodeTypes = {
            entryPoint: EntryPointNode,
            exitPoint: ExitPointNode,
            component: ComponentNode,
            technique: TechniqueNode,
        };
        
        // Palette Component
        const Palette = ({ onDragStart, selectedComponent, setSelectedComponent }) => {
            const [expandedSections, setExpandedSections] = useState({
                entry: true,
                components: true,
                techniques: false,
                exit: true
            });
            
            const [searchTerm, setSearchTerm] = useState('');
            
            const toggleSection = (section) => {
                setExpandedSections(prev => ({
                    ...prev,
                    [section]: !prev[section]
                }));
            };
            
            // Auto-expand techniques section when a component is selected
            useEffect(() => {
                if (selectedComponent !== 'all') {
                    setExpandedSections(prev => ({
                        ...prev,
                        techniques: true
                    }));
                }
            }, [selectedComponent]);
            
            // Return null if data not loaded yet
            if (!techniquesData) return null;
            
            const filteredTechniques = techniquesData.techniques.filter(tech => {
                const matchesSearch = tech.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                     tech.id.toLowerCase().includes(searchTerm.toLowerCase());
                const matchesComponent = selectedComponent === 'all' || tech.component === selectedComponent;
                return matchesSearch && matchesComponent;
            });
            
            return (
                <div className="flex flex-col h-full" style={{ width: '100%', background: 'var(--wiz-dark-surface)' }}>
                    <div className="p-4 border-b" style={{ borderColor: 'var(--wiz-dark-border)', background: 'var(--wiz-dark-bg)' }}>
                        <h2 className="text-lg font-bold" style={{ color: 'var(--wiz-text-primary)' }}>SITF Component Palette</h2>
                        <p className="text-xs mt-1" style={{ color: 'var(--wiz-text-secondary)' }}>Drag components to canvas</p>
                    </div>
                    
                    <div className="flex-1 overflow-y-auto scrollbar-thin">
                        {/* Entry Point */}
                        <div className="border-b" style={{ borderColor: 'var(--wiz-dark-border)' }}>
                            <div className="p-2">
                                <div
                                    draggable
                                    onDragStart={(e) => onDragStart(e, 'entryPoint', { label: 'Entry Point' })}
                                    className="palette-item p-3 mb-2 rounded cursor-grab"
                                    style={{
                                        background: 'rgba(16, 185, 129, 0.1)',
                                        border: '2px solid var(--wiz-success)',
                                        color: 'var(--wiz-text-primary)'
                                    }}
                                >
                                    <div className="text-sm font-bold" style={{ color: 'var(--wiz-success)' }}> Entry Point</div>
                                    <div className="text-xs mt-1" style={{ color: 'var(--wiz-text-secondary)' }}>Attack chain initiation</div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Components */}
                        <div className="border-b" style={{ borderColor: 'var(--wiz-dark-border)' }}>
                            <button
                                onClick={() => toggleSection('components')}
                                className="w-full p-3 text-left font-semibold text-sm flex justify-between items-center"
                                style={{
                                    background: 'var(--wiz-dark-bg)',
                                    color: 'var(--wiz-text-primary)',
                                    border: 'none',
                                    cursor: 'pointer',
                                    transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                onMouseLeave={(e) => e.currentTarget.style.background = 'var(--wiz-dark-bg)'}
                            >
                                <span> Infrastructure Components</span>
                                <span>{expandedSections.components ? '' : ''}</span>
                            </button>
                            {expandedSections.components && (
                                <div className="p-2">
                                    {techniquesData.components.map((comp) => (
                                        <div
                                            key={comp.id}
                                            draggable
                                            onDragStart={(e) => onDragStart(e, 'component', {
                                                label: comp.name,
                                                componentId: comp.id,
                                                techniques: []
                                            })}
                                            className="palette-item p-2 mb-2 rounded cursor-grab"
                                            style={{
                                                background: 'var(--wiz-dark-surface)',
                                                border: '2px solid var(--wiz-dark-border)',
                                                borderLeftColor: componentColors[comp.id],
                                                borderLeftWidth: '4px'
                                            }}
                                        >
                                            <div className="text-sm font-medium" style={{ color: componentColors[comp.id] }}>
                                                {comp.name}
                                            </div>
                                            <div className="text-xs mt-1" style={{ color: 'var(--wiz-text-secondary)' }}>{comp.description}</div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                        
                        {/* Techniques */}
                        <div className="border-b" style={{ borderColor: 'var(--wiz-dark-border)' }}>
                            <button
                                onClick={() => toggleSection('techniques')}
                                className="w-full p-3 text-left font-semibold text-sm flex justify-between items-center"
                                style={{
                                    background: 'var(--wiz-dark-bg)',
                                    color: 'var(--wiz-text-primary)',
                                    border: 'none',
                                    cursor: 'pointer',
                                    transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                onMouseLeave={(e) => e.currentTarget.style.background = 'var(--wiz-dark-bg)'}
                            >
                                <span> Attack Techniques ({filteredTechniques.length})</span>
                                <span>{expandedSections.techniques ? '' : ''}</span>
                            </button>
                            {expandedSections.techniques && (
                                <div className="p-2">
                                    <input
                                        type="text"
                                        placeholder="Search techniques..."
                                        value={searchTerm}
                                        onChange={(e) => setSearchTerm(e.target.value)}
                                        className="w-full p-2 mb-2 text-sm rounded"
                                        style={{
                                            background: 'var(--wiz-dark-bg)',
                                            border: '1px solid var(--wiz-dark-border)',
                                            color: 'var(--wiz-text-primary)'
                                        }}
                                    />
                                    <div className="mb-2">
                                        <select
                                            value={selectedComponent}
                                            onChange={(e) => setSelectedComponent(e.target.value)}
                                            className="w-full p-2 text-sm rounded"
                                            style={{
                                                background: 'var(--wiz-dark-bg)',
                                                borderWidth: '2px',
                                                borderStyle: 'solid',
                                                borderColor: selectedComponent !== 'all'
                                                    ? componentColors[selectedComponent]
                                                    : 'var(--wiz-dark-border)',
                                                color: 'var(--wiz-text-primary)'
                                            }}
                                        >
                                            <option value="all">All Components</option>
                                            {techniquesData.components.map(comp => (
                                                <option key={comp.id} value={comp.id}>{comp.name}</option>
                                            ))}
                                        </select>
                                        {selectedComponent !== 'all' && (
                                            <div className="mt-1 text-xs flex items-center justify-between" style={{ color: 'var(--wiz-text-secondary)' }}>
                                                <span>Filtered by component selection</span>
                                                <button
                                                    onClick={() => setSelectedComponent('all')}
                                                    className="underline"
                                                    style={{
                                                        color: 'var(--wiz-accent-purple)',
                                                        background: 'none',
                                                        border: 'none',
                                                        cursor: 'pointer'
                                                    }}
                                                >
                                                    Clear
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                    <div className="max-h-96 overflow-y-auto">
                                        {filteredTechniques.map((tech) => {
                                            const comp = techniquesData.components.find(c => c.id === tech.component);
                                            return (
                                                <div
                                                    key={tech.id}
                                                    draggable
                                                    onDragStart={(e) => onDragStart(e, 'technique', tech)}
                                                    className="palette-item p-2 mb-2 rounded cursor-grab"
                                                    style={{
                                                        background: 'var(--wiz-dark-surface)',
                                                        border: '1px solid var(--wiz-dark-border)',
                                                        borderLeftColor: componentColors[comp?.id],
                                                        borderLeftWidth: '3px'
                                                    }}
                                                >
                                                    <div className="text-xs font-bold" style={{ color: componentColors[comp?.id] }}>
                                                        {tech.id}
                                                    </div>
                                                    <div className="text-xs font-medium mt-1" style={{ color: 'var(--wiz-text-primary)' }}>
                                                        {tech.name}
                                                    </div>
                                                    <div className="text-xs mt-1" style={{ color: 'var(--wiz-text-secondary)' }}>
                                                        {Array.isArray(tech.stage) ? tech.stage.join(' / ') : tech.stage}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Exit Points */}
                        <div>
                            <button
                                onClick={() => toggleSection('exit')}
                                className="w-full p-3 text-left font-semibold text-sm flex justify-between items-center"
                                style={{
                                    background: 'var(--wiz-dark-bg)',
                                    color: 'var(--wiz-text-primary)',
                                    border: 'none',
                                    cursor: 'pointer',
                                    transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                onMouseLeave={(e) => e.currentTarget.style.background = 'var(--wiz-dark-bg)'}
                            >
                                <span> Exit Points</span>
                                <span>{expandedSections.exit ? '' : ''}</span>
                            </button>
                            {expandedSections.exit && (
                                <div className="p-2">
                                    {techniquesData.exitPoints.map((exit, idx) => (
                                        <div
                                            key={idx}
                                            draggable
                                            onDragStart={(e) => onDragStart(e, 'exitPoint', { label: exit })}
                                            className="palette-item p-2 mb-2 rounded cursor-grab"
                                            style={{
                                                background: 'rgba(239, 68, 68, 0.1)',
                                                border: '1px solid var(--wiz-danger)',
                                                color: 'var(--wiz-text-primary)'
                                            }}
                                        >
                                            <div className="text-sm font-medium" style={{ color: 'var(--wiz-danger)' }}>{exit}</div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };
        
        // Controls Matrix Component
        const ControlsMatrix = ({ nodes, matrixHeight, setMatrixHeight, isResizingMatrix, setIsResizingMatrix }) => {
            const [isCollapsed, setIsCollapsed] = useState(false);
            const [controlsData, setControlsData] = useState({ totalControls: 0, matrix: {} });
            
            // Export to CSV function
            const exportToCSV = useCallback(() => {
                if (!techniquesData) return;
                
                const mainStages = ['Initial Access', 'Discovery and Lateral Movement', 'Post-Compromise'];
                const components = techniquesData.components;
                
                // Build CSV content with one row per control, including control type
                let csv = 'Component,Stage,Control Type,Control,Status\n';
                
                components.forEach(comp => {
                    mainStages.forEach(stage => {
                        const cellData = controlsData.matrix[comp.id]?.[stage] || { protective: [], detective: [] };
                        // Handle both old format (array) and new format (object with protective/detective)
                        if (Array.isArray(cellData)) {
                            cellData.forEach(control => {
                                const escapedControl = control.replace(/"/g, '""');
                                csv += `"${comp.name}","${stage}","","${escapedControl}",""\n`;
                            });
                        } else {
                            (cellData.protective || []).forEach(control => {
                                const escapedControl = control.replace(/"/g, '""');
                                csv += `"${comp.name}","${stage}","Protective","${escapedControl}",""\n`;
                            });
                            (cellData.detective || []).forEach(control => {
                                const escapedControl = control.replace(/"/g, '""');
                                csv += `"${comp.name}","${stage}","Detective","${escapedControl}",""\n`;
                            });
                        }
                    });
                });
                
                // Create and download file
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `controls-matrix-${Date.now()}.csv`;
                link.click();
                URL.revokeObjectURL(url);
            }, [controlsData]);
            
            // Stage mapping: map all technique stages to 3 main columns
            const stageMapping = {
                'Initial Access': 'Initial Access',
                'Execution': 'Initial Access',
                'Persistence': 'Discovery and Lateral Movement',
                'Privilege Escalation': 'Discovery and Lateral Movement',
                'Defense Evasion': 'Discovery and Lateral Movement',
                'Credential Access': 'Discovery and Lateral Movement',
                'Discovery and Lateral Movement': 'Discovery and Lateral Movement',
                'Collection': 'Post-Compromise',
                'Command and Control': 'Post-Compromise',
                'Exfiltration': 'Post-Compromise',
                'Impact': 'Post-Compromise',
                'Post-Compromise': 'Post-Compromise'
            };
            
            const mainStages = ['Initial Access', 'Discovery and Lateral Movement', 'Post-Compromise'];
            const components = techniquesData?.components || [];
            
            // Rebuild matrix whenever nodes change
            useEffect(() => {
                if (!techniquesData) return;
                
                // Get all technique nodes on canvas
                const techniqueNodes = nodes.filter(n => n.type === 'technique');
                
                if (techniqueNodes.length === 0) {
                    setControlsData({ totalControls: 0, matrix: {} });
                    return;
                }
                
                // Build matrix: component  stage -> { protective: Set, detective: Set }
                const matrix = {};
                let totalControlsSet = new Set();
                
                components.forEach(comp => {
                    matrix[comp.id] = {};
                    mainStages.forEach(stage => {
                        matrix[comp.id][stage] = { protective: new Set(), detective: new Set() };
                    });
                });
                
                // Populate matrix from technique nodes
                techniqueNodes.forEach(node => {
                    const techData = techniquesData.techniques.find(t => t.id === node.data.id);
                    if (!techData) return;
                    
                    const component = techData.component;
                    const originalStage = techData.stage;
                    const mappedStage = stageMapping[originalStage] || 'Post-Compromise';
                    
                    // Add controls to appropriate cell (handle new schema with protective/detective)
                    if (matrix[component] && matrix[component][mappedStage]) {
                        const controls = techData.controls || {};
                        const protective = controls.protective || [];
                        const detective = controls.detective || [];
                        
                        protective.forEach(control => {
                            const controlName = control.name || control;
                            matrix[component][mappedStage].protective.add(controlName);
                            totalControlsSet.add(controlName);
                        });
                        
                        detective.forEach(control => {
                            const controlName = control.name || control;
                            matrix[component][mappedStage].detective.add(controlName);
                            totalControlsSet.add(controlName);
                        });
                    }
                });
                
                // Convert Sets to Arrays for rendering
                const matrixArrays = {};
                components.forEach(comp => {
                    matrixArrays[comp.id] = {};
                    mainStages.forEach(stage => {
                        matrixArrays[comp.id][stage] = {
                            protective: Array.from(matrix[comp.id][stage].protective),
                            detective: Array.from(matrix[comp.id][stage].detective)
                        };
                    });
                });
                
                setControlsData({
                    totalControls: totalControlsSet.size,
                    matrix: matrixArrays
                });
            }, [nodes]);
            
            const techniqueCount = nodes.filter(n => n.type === 'technique').length;
            
            // Matrix resize handlers
            const startMatrixResize = useCallback((e) => {
                setIsResizingMatrix(true);
                e.preventDefault();
            }, [setIsResizingMatrix]);
            
            return (
                <div className="border-t" style={{
                    height: isCollapsed ? 'auto' : `${matrixHeight}px`,
                    position: 'relative',
                    minHeight: '60px',
                    maxHeight: '600px',
                    borderColor: 'var(--wiz-dark-border)',
                    background: 'var(--wiz-dark-surface)'
                }}>
                    {!isCollapsed && (
                        <div
                            className={`matrix-resize-handle ${isResizingMatrix ? 'resizing' : ''}`}
                            onMouseDown={startMatrixResize}
                        />
                    )}
                    {/* Header */}
                    <div className="p-3 border-b flex justify-between items-center" style={{
                        background: 'var(--wiz-dark-surface)',
                        borderColor: 'var(--wiz-dark-border)'
                    }}>
                        <div
                            className="flex items-center gap-3 cursor-pointer flex-1"
                            onClick={() => setIsCollapsed(!isCollapsed)}
                            style={{ transition: 'opacity 0.2s' }}
                            onMouseEnter={(e) => e.currentTarget.style.opacity = '0.8'}
                            onMouseLeave={(e) => e.currentTarget.style.opacity = '1'}
                        >
                            <span className="text-lg font-bold" style={{ color: 'var(--wiz-text-primary)' }}>
                                {isCollapsed ? '' : ''}
                            </span>
                            <div>
                                <h3 className="text-sm font-bold" style={{ color: 'var(--wiz-text-primary)' }}>
                                    Controls Matrix
                                </h3>
                                <p className="text-xs" style={{ color: 'var(--wiz-text-secondary)' }}>
                                    {techniqueCount} technique{techniqueCount !== 1 ? 's' : ''} on canvas
                                    {controlsData.totalControls > 0 && ` -> ${controlsData.totalControls} unique control${controlsData.totalControls !== 1 ? 's' : ''}`}
                                </p>
                            </div>
                        </div>
                        {techniqueCount > 0 && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    exportToCSV();
                                }}
                                className="wiz-button wiz-button-success text-xs flex items-center gap-1"
                                title="Export controls matrix to CSV"
                            >
                                 Export CSV
                            </button>
                        )}
                    </div>
                    
                    {/* Matrix Content */}
                    {!isCollapsed && (
                        <div className="p-4 overflow-auto" style={{
                            height: `${matrixHeight - 60}px`,
                            maxHeight: `${matrixHeight - 60}px`,
                            background: 'var(--wiz-dark-bg)'
                        }}>
                            {techniqueCount === 0 ? (
                                <div className="text-center py-8" style={{ color: 'var(--wiz-text-secondary)' }}>
                                    <div className="text-4xl mb-2"></div>
                                    <p className="text-sm">Add techniques to the canvas to see associated security controls</p>
                                </div>
                            ) : (
                                <table className="w-full border-collapse text-xs">
                                    <thead>
                                        <tr>
                                            <th className="p-2 text-left font-bold sticky left-0 z-10" style={{
                                                border: '1px solid var(--wiz-dark-border)',
                                                background: 'var(--wiz-dark-surface)',
                                                color: 'var(--wiz-text-primary)'
                                            }}>
                                                Component
                                            </th>
                                            {mainStages.map(stage => (
                                                <th key={stage} className="p-2 text-center font-bold min-w-[200px]" style={{
                                                    border: '1px solid var(--wiz-dark-border)',
                                                    background: 'rgba(74, 144, 226, 0.1)',
                                                    color: 'var(--wiz-accent-blue)'
                                                }}>
                                                    {stage}
                                                </th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {components.map(comp => {
                                            const hasAnyControls = mainStages.some(stage => {
                                                const cellData = controlsData.matrix[comp.id]?.[stage] || { protective: [], detective: [] };
                                                return (cellData.protective?.length > 0) || (cellData.detective?.length > 0);
                                            });
                                            
                                            if (!hasAnyControls) return null;
                                            
                                            return (
                                                <tr key={comp.id}>
                                                    <td
                                                        className="p-2 font-semibold sticky left-0 z-10"
                                                        style={{
                                                            border: '1px solid var(--wiz-dark-border)',
                                                            background: 'var(--wiz-dark-surface)',
                                                            color: componentColors[comp.id]
                                                        }}
                                                    >
                                                        {comp.name}
                                                    </td>
                                                    {mainStages.map(stage => {
                                                        const cellData = controlsData.matrix[comp.id]?.[stage] || { protective: [], detective: [] };
                                                        const hasProtective = cellData.protective?.length > 0;
                                                        const hasDetective = cellData.detective?.length > 0;
                                                        return (
                                                            <td key={stage} className="p-2 align-top" style={{
                                                                border: '1px solid var(--wiz-dark-border)',
                                                                background: 'var(--wiz-dark-surface)'
                                                            }}>
                                                                {(hasProtective || hasDetective) ? (
                                                                    <div className="space-y-2">
                                                                        {hasProtective && (
                                                                            <div>
                                                                                <div className="text-xs font-semibold mb-1" style={{ color: '#10B981' }}> Protective</div>
                                                                                <ul className="list-disc list-inside space-y-0.5" style={{ marginLeft: '4px' }}>
                                                                                    {cellData.protective.map((control, idx) => (
                                                                                        <li key={idx} style={{ color: 'var(--wiz-text-primary)', fontSize: '11px' }}>
                                                                                            {control}
                                                                                        </li>
                                                                                    ))}
                                                                                </ul>
                                                                            </div>
                                                                        )}
                                                                        {hasDetective && (
                                                                            <div>
                                                                                <div className="text-xs font-semibold mb-1" style={{ color: '#F59E0B' }}> Detective</div>
                                                                                <ul className="list-disc list-inside space-y-0.5" style={{ marginLeft: '4px' }}>
                                                                                    {cellData.detective.map((control, idx) => (
                                                                                        <li key={idx} style={{ color: 'var(--wiz-text-primary)', fontSize: '11px' }}>
                                                                                            {control}
                                                                                        </li>
                                                                                    ))}
                                                                                </ul>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                ) : (
                                                                    <span className="italic" style={{ color: 'var(--wiz-text-secondary)' }}></span>
                                                                )}
                                                            </td>
                                                        );
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            )}
                        </div>
                    )}
                </div>
            );
        };
        
        // Main App Component
        const App = () => {
            const reactFlowWrapper = useRef(null);
            const [nodes, setNodes, onNodesChange] = useNodesState([]);
            const [edges, setEdges, onEdgesChange] = useEdgesState([]);
            const [reactFlowInstance, setReactFlowInstance] = useState(null);
            const [draggedItem, setDraggedItem] = useState(null);
            const [showExportMenu, setShowExportMenu] = useState(false);
            const [selectedComponent, setSelectedComponent] = useState('all');
            const [sidebarWidth, setSidebarWidth] = useState(300);
            const [isResizing, setIsResizing] = useState(false);
            const [matrixHeight, setMatrixHeight] = useState(300);
            const [isResizingMatrix, setIsResizingMatrix] = useState(false);
            const [isDarkMode, setIsDarkMode] = useState(true);
            
            // History management for undo/redo
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const isUndoRedoAction = useRef(false);
            const saveTimeoutRef = useRef(null);
            
            const onConnect = useCallback(
                (params) => {
                    const edgeColor = isDarkMode ? '#666666' : '#9ca3af';
                    const newEdge = {
                        ...params,
                        type: 'smoothstep',
                        animated: false,
                        style: { stroke: edgeColor },
                        markerEnd: {
                            type: MarkerType.ArrowClosed,
                            color: edgeColor
                        },
                        label: '',
                        labelStyle: { fill: '#DC2626', fontWeight: 600, fontSize: 12 },
                        labelBgStyle: { fill: '#FEE2E2', fillOpacity: 0.9 }
                    };
                    setEdges((eds) => addEdge(newEdge, eds));
                },
                [setEdges, isDarkMode]
            );
            
            // Make edge labels editable with impact types - using a modal dialog
            const onEdgeUpdate = useCallback((oldEdge, newConnection) => {
                setEdges((els) => els.map((e) => (e.id === oldEdge.id ? { ...e, ...newConnection } : e)));
            }, [setEdges]);
            
            const onEdgeDoubleClick = useCallback((event, edge) => {
                event.stopPropagation();
                
                if (!techniquesData?.impactTypes) return;
                
                // Combine all impact types into a single flat list
                const allImpacts = [
                    ...techniquesData.impactTypes.primary,
                    ...techniquesData.impactTypes.secondary
                ];
                
                // Remove duplicates and create selection list
                const uniqueImpacts = [...new Set(allImpacts)];
                const impactOptions = [
                    ...uniqueImpacts.map(i => ({ label: i, value: i })),
                    { label: 'No Label', value: '' }
                ];
                
                const options = impactOptions
                    .map((item, idx) => `${idx}. ${item.label}`)
                    .join('\n');
                
                const selection = prompt(
                    'Select Impact Type:\n\n' + options + '\n\nEnter number or custom text:',
                    edge.label || ''
                );
                
                if (selection !== null) {
                    let newLabel = selection.trim();
                    
                    // Check if it's a number selection
                    const num = parseInt(selection);
                    if (!isNaN(num) && num >= 0 && num < impactOptions.length) {
                        newLabel = impactOptions[num].value;
                    }
                    
                    setEdges((eds) => eds.map((e) =>
                        e.id === edge.id ? {
                            ...e,
                            label: newLabel,
                            labelStyle: { fill: '#DC2626', fontWeight: 600, fontSize: 12 },
                            labelBgStyle: { fill: '#FEE2E2', fillOpacity: 0.9 }
                        } : e
                    ));
                }
            }, [setEdges]);
            
            const onDragStart = (event, nodeType, data) => {
                setDraggedItem({ type: nodeType, data });
                event.dataTransfer.effectAllowed = 'move';
            };
            
            const onDragOver = useCallback((event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }, []);
            
            const onDrop = useCallback(
                (event) => {
                    event.preventDefault();
                    
                    if (!draggedItem || !reactFlowInstance) return;
                    
                    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
                    const position = reactFlowInstance.project({
                        x: event.clientX - reactFlowBounds.left,
                        y: event.clientY - reactFlowBounds.top,
                    });
                    
                    const newNode = {
                        id: `${draggedItem.type}-${Date.now()}`,
                        type: draggedItem.type,
                        position,
                        data: draggedItem.data,
                        // Set z-index: components always in background, other nodes on top
                        zIndex: draggedItem.type === 'component' ? -1 : 10,
                    };
                    
                    setNodes((nds) => nds.concat(newNode));
                    setDraggedItem(null);
                },
                [draggedItem, reactFlowInstance, setNodes]
            );
            
            const exportToPNG = useCallback(() => {
                if (!reactFlowInstance) return;
                
                // Temporarily hide expansion buttons and any open popups
                const buttons = document.querySelectorAll('button[title="Show Risks"], button[title="Show Controls"]');
                buttons.forEach(btn => btn.style.display = 'none');
                
                // Use React Flow's getNodes to get viewport bounds including all child elements
                const nodesBounds = reactFlowInstance.getNodes().reduce(
                    (acc, node) => {
                        const nodeElement = document.querySelector(`[data-id="${node.id}"]`);
                        if (nodeElement) {
                            // Get the full bounding box including all children
                            const rect = nodeElement.getBoundingClientRect();
                            
                            // For technique nodes, account for potential popup panels (200px each side)
                            let extraWidth = 0;
                            let extraLeft = 0;
                            if (node.type === 'technique') {
                                extraLeft = 220; // Space for risks popup on left
                                extraWidth = 220; // Space for controls popup on right
                            }
                            
                            const nodeWidth = (rect.width || nodeElement.offsetWidth || 200) + extraWidth;
                            const nodeHeight = rect.height || nodeElement.offsetHeight || 100;
                            
                            return {
                                minX: Math.min(acc.minX, node.position.x - extraLeft),
                                minY: Math.min(acc.minY, node.position.y),
                                maxX: Math.max(acc.maxX, node.position.x + nodeWidth),
                                maxY: Math.max(acc.maxY, node.position.y + nodeHeight),
                            };
                        }
                        return acc;
                    },
                    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
                );
                
                // If no nodes, use default viewport
                if (nodesBounds.minX === Infinity) {
                    nodesBounds.minX = 0;
                    nodesBounds.minY = 0;
                    nodesBounds.maxX = 800;
                    nodesBounds.maxY = 600;
                }
                
                const padding = 50;
                const width = nodesBounds.maxX - nodesBounds.minX + padding * 2;
                const height = nodesBounds.maxY - nodesBounds.minY + padding * 2;
                
                // Get the viewport element
                const viewport = document.querySelector('.react-flow__viewport');
                if (!viewport) {
                    buttons.forEach(btn => btn.style.display = '');
                    return;
                }
                
                // Create a temporary container with white background
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.top = '0';
                tempContainer.style.width = `${width}px`;
                tempContainer.style.height = `${height}px`;
                tempContainer.style.backgroundColor = '#ffffff';
                tempContainer.style.overflow = 'visible';
                document.body.appendChild(tempContainer);
                
                // Clone the viewport
                const clonedViewport = viewport.cloneNode(true);
                clonedViewport.style.transform = `translate(${padding - nodesBounds.minX}px, ${padding - nodesBounds.minY}px)`;
                clonedViewport.style.overflow = 'visible';
                tempContainer.appendChild(clonedViewport);
                
                setTimeout(() => {
                    html2canvas(tempContainer, {
                        backgroundColor: '#ffffff',
                        scale: 2,
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        width: width,
                        height: height,
                    }).then(canvas => {
                        // Cleanup
                        document.body.removeChild(tempContainer);
                        buttons.forEach(btn => btn.style.display = '');
                        
                        const link = document.createElement('a');
                        link.download = `attack-flow-${Date.now()}.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    }).catch(err => {
                        // Cleanup on error
                        document.body.removeChild(tempContainer);
                        buttons.forEach(btn => btn.style.display = '');
                        console.error('Export error:', err);
                    });
                }, 200);
            }, [reactFlowInstance]);
            
            const exportToSVG = useCallback(() => {
                if (!reactFlowInstance) return;
                
                const flowElement = document.querySelector('.react-flow__viewport');
                if (!flowElement) return;
                
                // Get the bounding box
                const bbox = flowElement.getBoundingClientRect();
                const svgWidth = bbox.width;
                const svgHeight = bbox.height;
                
                // Create SVG
                let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">
    <rect width="100%" height="100%" fill="#ffffff"/>
    <g>`;
                
                // Add nodes
                nodes.forEach(node => {
                    const nodeElement = document.querySelector(`[data-id="${node.id}"]`);
                    if (!nodeElement) return;
                    
                    const nodeBbox = nodeElement.getBoundingClientRect();
                    const x = node.position.x;
                    const y = node.position.y;
                    
                    let color = '#3B82F6';
                    if (node.type === 'entryPoint') color = '#10B981';
                    if (node.type === 'exitPoint') color = '#EF4444';
                    if (node.type === 'component') {
                        color = componentColors[node.data.componentId] || '#6B7280';
                    }
                    
                    svgContent += `
        <rect x="${x}" y="${y}" width="${nodeBbox.width}" height="${nodeBbox.height}"
              fill="white" stroke="${color}" stroke-width="2" rx="8"/>
        <text x="${x + 10}" y="${y + 25}" font-family="Arial" font-size="14" fill="${color}" font-weight="bold">
            ${node.data.label || node.id}
        </text>`;
                });
                
                // Add edges
                edges.forEach(edge => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    const targetNode = nodes.find(n => n.id === edge.target);
                    if (!sourceNode || !targetNode) return;
                    
                    const sourceElement = document.querySelector(`[data-id="${edge.source}"]`);
                    const targetElement = document.querySelector(`[data-id="${edge.target}"]`);
                    if (!sourceElement || !targetElement) return;
                    
                    const sourceBbox = sourceElement.getBoundingClientRect();
                    const targetBbox = targetElement.getBoundingClientRect();
                    
                    const x1 = sourceNode.position.x + sourceBbox.width;
                    const y1 = sourceNode.position.y + sourceBbox.height / 2;
                    const x2 = targetNode.position.x;
                    const y2 = targetNode.position.y + targetBbox.height / 2;
                    
                    svgContent += `
        <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"
              stroke="#6B7280" stroke-width="2" marker-end="url(#arrowhead)"/>`;
                });
                
                svgContent += `
    </g>
    <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <polygon points="0 0, 10 3, 0 6" fill="#6B7280"/>
        </marker>
    </defs>
</svg>`;
                
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `attack-flow-${Date.now()}.svg`;
                link.click();
                URL.revokeObjectURL(url);
            }, [reactFlowInstance, nodes, edges]);
            
            const exportToPDF = useCallback(() => {
                const flowElement = document.querySelector('.react-flow');
                if (!flowElement) return;
                
                html2canvas(flowElement, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false,
                    useCORS: true,
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    
                    // Calculate PDF dimensions
                    const imgWidth = canvas.width;
                    const imgHeight = canvas.height;
                    const ratio = imgWidth / imgHeight;
                    
                    // Use landscape A4 if wide, portrait if tall
                    const pdfWidth = ratio > 1 ? 297 : 210;
                    const pdfHeight = ratio > 1 ? 210 : 297;
                    
                    const pdf = new jsPDF({
                        orientation: ratio > 1 ? 'landscape' : 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });
                    
                    // Add title page
                    pdf.setFontSize(24);
                    pdf.text('SITF Attack Flow', pdfWidth / 2, 30, { align: 'center' });
                    
                    pdf.setFontSize(12);
                    pdf.text(`Generated: ${new Date().toLocaleString()}`, pdfWidth / 2, 45, { align: 'center' });
                    pdf.text(`Framework: SDLC Infrastructure Threat Framework`, pdfWidth / 2, 55, { align: 'center' });
                    
                    // Add diagram on second page
                    pdf.addPage();
                    
                    // Fit image to page with margins
                    const margin = 10;
                    const availableWidth = pdfWidth - (2 * margin);
                    const availableHeight = pdfHeight - (2 * margin);
                    
                    let finalWidth = availableWidth;
                    let finalHeight = finalWidth / ratio;
                    
                    if (finalHeight > availableHeight) {
                        finalHeight = availableHeight;
                        finalWidth = finalHeight * ratio;
                    }
                    
                    const xOffset = (pdfWidth - finalWidth) / 2;
                    const yOffset = (pdfHeight - finalHeight) / 2;
                    
                    pdf.addImage(imgData, 'PNG', xOffset, yOffset, finalWidth, finalHeight);
                    
                    pdf.save(`attack-flow-${Date.now()}.pdf`);
                });
            }, []);
            
            const exportWithCustomDimensions = useCallback(() => {
                const width = prompt('Enter width in pixels (default: current size):', '');
                const height = prompt('Enter height in pixels (default: current size):', '');
                
                if (width || height) {
                    const flowElement = document.querySelector('.react-flow');
                    if (!flowElement) return;
                    
                    const originalWidth = flowElement.style.width;
                    const originalHeight = flowElement.style.height;
                    
                    if (width) flowElement.style.width = `${width}px`;
                    if (height) flowElement.style.height = `${height}px`;
                    
                    setTimeout(() => {
                        exportToPNG(3);
                        flowElement.style.width = originalWidth;
                        flowElement.style.height = originalHeight;
                    }, 100);
                } else {
                    exportToPNG(3);
                }
            }, [exportToPNG]);
            
            const saveToFile = useCallback(() => {
                // Format timestamp: YYYY-MM-DD_HH-MM
                const now = new Date();
                const timestamp = now.getFullYear() + '-' +
                    String(now.getMonth() + 1).padStart(2, '0') + '-' +
                    String(now.getDate()).padStart(2, '0') + '_' +
                    String(now.getHours()).padStart(2, '0') + '-' +
                    String(now.getMinutes()).padStart(2, '0');
                
                const flowData = {
                    metadata: {
                        name: 'Attack Flow',
                        created: new Date().toISOString(),
                        version: '1.0',
                        framework: 'SITF'
                    },
                    nodes,
                    edges
                };
                
                const dataStr = JSON.stringify(flowData, null, 2);
                
                // Generate filename with readable timestamp
                const suggestedFilename = `attack-flow_${timestamp}.json`;
                
                // Try to use File System Access API (modern browsers)
                if ('showSaveFilePicker' in window) {
                    const options = {
                        suggestedName: suggestedFilename,
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    };
                    
                    // Call showSaveFilePicker synchronously within user gesture
                    window.showSaveFilePicker(options)
                        .then(handle => handle.createWritable())
                        .then(writable => {
                            return writable.write(dataStr).then(() => writable.close());
                        })
                        .catch(err => {
                            // User cancelled or error occurred
                            if (err.name !== 'AbortError') {
                                console.error('Error saving file:', err);
                            }
                        });
                    return;
                }
                
                // Fallback for browsers without File System Access API
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = suggestedFilename;
                link.click();
                URL.revokeObjectURL(url);
            }, [nodes, edges]);
            
            const loadFromFile = useCallback(() => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const flowData = JSON.parse(event.target.result);
                            
                            // Validate structure
                            if (!flowData.nodes || !flowData.edges) {
                                alert(' Error\n\nInvalid file format: missing nodes or edges.\n\nPlease select a valid SITF attack flow JSON file.');
                                return;
                            }
                            
                            // Confirm before loading
                            const metadata = flowData.metadata || {};
                            const createdDate = metadata.created ? new Date(metadata.created).toLocaleString() : 'Unknown';
                            const nodeCount = flowData.nodes.length;
                            const edgeCount = flowData.edges.length;
                            
                            const message = ` Load Attack Flow\n\n` +
                                `Name: ${metadata.name || 'Unknown'}\n` +
                                `Created: ${createdDate}\n` +
                                `Nodes: ${nodeCount} | Edges: ${edgeCount}\n\n` +
                                ` This will replace your current work.\n\n` +
                                `Continue?`;
                            
                            if (confirm(message)) {
                                // Ensure components have z-index -1 when loading
                                const nodesWithZIndex = flowData.nodes.map(node => ({
                                    ...node,
                                    zIndex: node.type === 'component' ? -1 : (node.zIndex || 10)
                                }));
                                setNodes(nodesWithZIndex);
                                setEdges(flowData.edges);
                            }
                        } catch (error) {
                            alert(` Error Loading File\n\n${error.message}\n\nPlease check the file format and try again.`);
                            console.error('Load error:', error);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }, [setNodes, setEdges]);
            
            const clearCanvas = useCallback(() => {
                const nodeCount = nodes.length;
                const edgeCount = edges.length;
                
                if (nodeCount === 0 && edgeCount === 0) {
                    alert(' Canvas is already empty.');
                    return;
                }
                
                const message = ` Clear Canvas\n\n` +
                    `This will remove:\n` +
                    ` ${nodeCount} node${nodeCount !== 1 ? 's' : ''}\n` +
                    ` ${edgeCount} connection${edgeCount !== 1 ? 's' : ''}\n\n` +
                    ` This action cannot be undone.\n\n` +
                    `Continue?`;
                
                if (confirm(message)) {
                    setNodes([]);
                    setEdges([]);
                    alert(' Canvas cleared successfully.');
                }
            }, [nodes, edges, setNodes, setEdges]);
            
            // Handle node selection - auto-filter techniques when component is selected
            const handleNodeClick = useCallback((event, node) => {
                if (node.type === 'component' && node.data.componentId) {
                    setSelectedComponent(node.data.componentId);
                }
            }, []);
            
            // Save state to history (for undo/redo) with debouncing
            const saveToHistory = useCallback((newNodes, newEdges) => {
                if (isUndoRedoAction.current) {
                    isUndoRedoAction.current = false;
                    return;
                }
                
                // Clear existing timeout
                if (saveTimeoutRef.current) {
                    clearTimeout(saveTimeoutRef.current);
                }
                
                // Debounce: wait 500ms after last change before saving to history
                saveTimeoutRef.current = setTimeout(() => {
                    const newState = {
                        nodes: JSON.parse(JSON.stringify(newNodes)),
                        edges: JSON.parse(JSON.stringify(newEdges))
                    };
                    
                    setHistory(prev => {
                        const newHistory = prev.slice(0, historyIndex + 1);
                        newHistory.push(newState);
                        if (newHistory.length > 50) {
                            newHistory.shift();
                            return newHistory;
                        }
                        return newHistory;
                    });
                    
                    setHistoryIndex(prev => Math.min(prev + 1, 49));
                }, 500);
            }, [historyIndex]);
            
            // Undo function
            const undo = useCallback(() => {
                if (historyIndex > 0) {
                    isUndoRedoAction.current = true;
                    const prevState = history[historyIndex - 1];
                    setNodes(prevState.nodes);
                    setEdges(prevState.edges);
                    setHistoryIndex(prev => prev - 1);
                }
            }, [history, historyIndex, setNodes, setEdges]);
            
            // Redo function
            const redo = useCallback(() => {
                if (historyIndex < history.length - 1) {
                    isUndoRedoAction.current = true;
                    const nextState = history[historyIndex + 1];
                    setNodes(nextState.nodes);
                    setEdges(nextState.edges);
                    setHistoryIndex(prev => prev + 1);
                }
            }, [history, historyIndex, setNodes, setEdges]);
            
            // Track changes to nodes/edges and save to history
            useEffect(() => {
                if (nodes.length > 0 || edges.length > 0) {
                    saveToHistory(nodes, edges);
                }
            }, [nodes, edges]);
            
            // Sidebar resize handlers
            const startResize = React.useCallback((e) => {
                setIsResizing(true);
                e.preventDefault();
            }, []);
            
            React.useEffect(() => {
                if (!isResizing) return;
                
                const handleMouseMove = (e) => {
                    const newWidth = e.clientX;
                    if (newWidth >= 200 && newWidth <= 600) {
                        setSidebarWidth(newWidth);
                    }
                };
                
                const handleMouseUp = () => {
                    setIsResizing(false);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing]);
            
            // Matrix resize effect
            useEffect(() => {
                if (!isResizingMatrix) return;
                
                const handleMouseMove = (e) => {
                    const windowHeight = window.innerHeight;
                    const newHeight = windowHeight - e.clientY;
                    if (newHeight >= 100 && newHeight <= 600) {
                        setMatrixHeight(newHeight);
                    }
                };
                
                const handleMouseUp = () => {
                    setIsResizingMatrix(false);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizingMatrix]);
            
            // Keyboard shortcuts for undo/redo
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        redo();
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo, redo]);
            
            // Toggle theme
            const toggleTheme = useCallback(() => {
                setIsDarkMode(prev => {
                    const newMode = !prev;
                    localStorage.setItem('sitf-theme', newMode ? 'dark' : 'light');
                    document.documentElement.className = newMode ? 'theme-dark' : 'theme-light';
                    return newMode;
                });
            }, []);
            
            // Load theme preference on mount
            useEffect(() => {
                const savedTheme = localStorage.getItem('sitf-theme');
                if (savedTheme) {
                    const isDark = savedTheme === 'dark';
                    setIsDarkMode(isDark);
                    document.documentElement.className = isDark ? 'theme-dark' : 'theme-light';
                }
            }, []);
            
            // Auto-save to localStorage
            useEffect(() => {
                const saveData = { nodes, edges };
                localStorage.setItem('sitf-attack-flow', JSON.stringify(saveData));
            }, [nodes, edges]);
            
            // Load from localStorage on mount
            useEffect(() => {
                const saved = localStorage.getItem('sitf-attack-flow');
                if (saved) {
                    try {
                        const { nodes: savedNodes, edges: savedEdges } = JSON.parse(saved);
                        if (savedNodes) {
                            // Ensure components have z-index -1 when loading from localStorage
                            const nodesWithZIndex = savedNodes.map(node => ({
                                ...node,
                                zIndex: node.type === 'component' ? -1 : (node.zIndex || 10)
                            }));
                            setNodes(nodesWithZIndex);
                        }
                        if (savedEdges) setEdges(savedEdges);
                    } catch (e) {
                        console.error('Failed to load saved data:', e);
                    }
                }
            }, []);
            
            // Close export menu when clicking outside
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (showExportMenu && !event.target.closest('.relative')) {
                        setShowExportMenu(false);
                    }
                };
                
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showExportMenu]);
            
            return (
                <div className="flex h-screen">
                    <div className="palette-container" style={{ width: `${sidebarWidth}px` }}>
                        <div
                            className={`resize-handle ${isResizing ? 'resizing' : ''}`}
                            onMouseDown={startResize}
                        />
                        <Palette
                            onDragStart={onDragStart}
                            selectedComponent={selectedComponent}
                            setSelectedComponent={setSelectedComponent}
                        />
                    </div>
                    
                    <div className="flex-1 flex flex-col">
                        {/* Header */}
                        <div className="border-b p-4 flex justify-between items-center" style={{
                            background: 'var(--wiz-dark-surface)',
                            borderColor: 'var(--wiz-dark-border)'
                        }}>
                            <div>
                                <div className="flex items-center gap-3">
                                    <h1 className="text-xl font-bold" style={{ color: 'var(--wiz-text-primary)' }}>
                                        SITF Attack Flow Visualizer
                                    </h1>
                                    <a
                                        href="techniques-library.html"
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="text-sm"
                                        style={{
                                            color: 'var(--wiz-accent-purple)',
                                            textDecoration: 'none',
                                            padding: '4px 12px',
                                            borderRadius: '6px',
                                            border: '1px solid var(--wiz-accent-purple)',
                                            transition: 'all 0.2s',
                                            fontWeight: 500
                                        }}
                                        onMouseEnter={(e) => {
                                            e.currentTarget.style.background = 'var(--wiz-accent-purple)';
                                            e.currentTarget.style.color = 'var(--wiz-dark-bg)';
                                        }}
                                        onMouseLeave={(e) => {
                                            e.currentTarget.style.background = 'transparent';
                                            e.currentTarget.style.color = 'var(--wiz-accent-purple)';
                                        }}
                                    >
                                         Technique Library
                                    </a>
                                </div>
                                <p className="text-sm" style={{ color: 'var(--wiz-text-secondary)' }}>
                                    Drag components from palette  Hold Shift + drag to select multiple  Shift + click to add to selection
                                </p>
                                <p className="text-xs mt-1" style={{ color: 'var(--wiz-text-secondary)', opacity: 0.7 }}>
                                    Made with <span style={{ color: '#FC80FF' }}></span> by <a href="https://www.wiz.io" target="_blank" rel="noopener noreferrer" style={{ color: 'var(--wiz-accent-purple)', textDecoration: 'none', fontWeight: 500 }}>Wiz</a>
                                </p>
                            </div>
                            <div className="flex gap-2 relative items-center">
                                {/* Theme Toggle */}
                                <button
                                    onClick={toggleTheme}
                                    className="wiz-button wiz-button-secondary"
                                    title={isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
                                    style={{ padding: '8px 12px' }}
                                >
                                    {isDarkMode ? '' : ''}
                                </button>
                                <button
                                    onClick={loadFromFile}
                                    className="wiz-button wiz-button-success"
                                >
                                     Load
                                </button>
                                <button
                                    onClick={saveToFile}
                                    className="wiz-button wiz-button-primary"
                                >
                                     Save
                                </button>
                                <button
                                    onClick={clearCanvas}
                                    className="wiz-button wiz-button-secondary"
                                >
                                     Clear
                                </button>
                                <div className="relative">
                                    <button
                                        onClick={() => setShowExportMenu(!showExportMenu)}
                                        className="wiz-button wiz-button-secondary flex items-center gap-2"
                                    >
                                         Export {showExportMenu ? '' : ''}
                                    </button>
                                    {showExportMenu && (
                                        <div className="absolute right-0 mt-2 w-56 rounded-lg shadow-xl z-50" style={{
                                            background: 'var(--wiz-dark-surface)',
                                            border: '1px solid var(--wiz-dark-border)'
                                        }}>
                                            <div className="py-1">
                                                <button
                                                    onClick={() => {
                                                        exportToPNG(3);
                                                        setShowExportMenu(false);
                                                    }}
                                                    className="w-full text-left px-4 py-2 text-sm flex items-center gap-2"
                                                    style={{
                                                        color: 'var(--wiz-text-primary)',
                                                        background: 'transparent',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        transition: 'background 0.2s'
                                                    }}
                                                    onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                                >
                                                    <span style={{ color: 'var(--wiz-accent-blue)' }}></span>
                                                    <div>
                                                        <div className="font-medium">PNG Image</div>
                                                        <div className="text-xs" style={{ color: 'var(--wiz-text-secondary)' }}>High quality (3x)</div>
                                                    </div>
                                                </button>
                                                <div className="my-1" style={{ borderTop: '1px solid var(--wiz-dark-border)' }}></div>
                                                <button
                                                    onClick={() => {
                                                        exportToSVG();
                                                        setShowExportMenu(false);
                                                    }}
                                                    className="w-full text-left px-4 py-2 text-sm flex items-center gap-2"
                                                    style={{
                                                        color: 'var(--wiz-text-primary)',
                                                        background: 'transparent',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        transition: 'background 0.2s'
                                                    }}
                                                    onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                                >
                                                    <span style={{ color: 'var(--wiz-accent-purple)' }}></span>
                                                    <div>
                                                        <div className="font-medium">SVG (Vector)</div>
                                                        <div className="text-xs" style={{ color: 'var(--wiz-text-secondary)' }}>Scalable format</div>
                                                    </div>
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        exportToPDF();
                                                        setShowExportMenu(false);
                                                    }}
                                                    className="w-full text-left px-4 py-2 text-sm flex items-center gap-2"
                                                    style={{
                                                        color: 'var(--wiz-text-primary)',
                                                        background: 'transparent',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        transition: 'background 0.2s'
                                                    }}
                                                    onMouseEnter={(e) => e.currentTarget.style.background = 'var(--wiz-dark-hover)'}
                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                                >
                                                    <span style={{ color: 'var(--wiz-danger)' }}></span>
                                                    <div>
                                                        <div className="font-medium">PDF Document</div>
                                                        <div className="text-xs" style={{ color: 'var(--wiz-text-secondary)' }}>With title page</div>
                                                    </div>
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        
                        {/* Canvas */}
                        <div ref={reactFlowWrapper} className="flex-1" style={{ height: 'calc(100vh - 80px - 300px)' }}>
                            <ReactFlow
                                nodes={nodes}
                                edges={edges}
                                onNodesChange={onNodesChange}
                                onEdgesChange={onEdgesChange}
                                onConnect={onConnect}
                                onEdgeUpdate={onEdgeUpdate}
                                onEdgeDoubleClick={onEdgeDoubleClick}
                                onNodeClick={handleNodeClick}
                                onInit={setReactFlowInstance}
                                onDrop={onDrop}
                                onDragOver={onDragOver}
                                nodeTypes={nodeTypes}
                                defaultEdgeOptions={{
                                    zIndex: 100
                                }}
                                elevateNodesOnSelect={false}
                                elevateEdgesOnSelect={true}
                                multiSelectionKeyCode="Shift"
                                selectionKeyCode="Shift"
                                panOnDrag={[1, 2]}
                                selectionOnDrag
                                defaultViewport={{ x: 0, y: 0, zoom: 0.75 }}
                                fitView
                            >
                                <Background color={isDarkMode ? "#333333" : "#e5e5e5"} gap={16} />
                                <Controls />
                            </ReactFlow>
                        </div>
                        
                        {/* Controls Matrix */}
                        <ControlsMatrix
                            nodes={nodes}
                            matrixHeight={matrixHeight}
                            setMatrixHeight={setMatrixHeight}
                            isResizingMatrix={isResizingMatrix}
                            setIsResizingMatrix={setIsResizingMatrix}
                        />
                    </div>
                </div>
            );
        };
        
        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>